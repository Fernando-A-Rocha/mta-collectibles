--[[
    Author: https://github.com/Fernando-A-Rocha

    Collectibles - System Administration/Management (Server)

    /!\ Unless you know what you are doing, do not edit this file. /!\
]]

-- Internal Events
addEvent("collectibles:updateConfig", true) -- source: always resourceRoot
addEvent("collectibles:createNewType", true) -- source: always resourceRoot
addEvent("collectibles:deleteType", true) -- source: always resourceRoot
addEvent("collectibles:backupConfig", true) -- source: always resourceRoot
addEvent("collectibles:restoreConfigBackup", true) -- source: always resourceRoot
addEvent("collectibles:requestConfigureSpawnpoints", true) -- source: always resourceRoot
addEvent("collectibles:gotoSpawnpoint", true) -- source: always resourceRoot
addEvent("collectibles:removeSpawnpoint", true) -- source: always resourceRoot
addEvent("collectibles:createSpawnpoint", true) -- source: always resourceRoot

local antiSpam = {}
local goingToRestart = false

function commandSpawnCollectibles(thePlayer, cmd, theType)
    if not canManageCollectibles(thePlayer) then
        outputCustomText(thePlayer, "admin_no_permission")
        return
    end
    if not theType then
        outputCustomText(thePlayer, "command_syntax", cmd, "[collectible type]")
        return
    end
    spawnCollectibles(theType, thePlayer)
end

function commandDestroyCollectibles(thePlayer, cmd, theType)
    if not canManageCollectibles(thePlayer) then
        outputCustomText(thePlayer, "admin_no_permission")
        return
    end
    if not theType then
        outputCustomText(thePlayer, "command_syntax", cmd, "[collectible type]")
        return
    end
    destroyCollectibles(theType, thePlayer)
end

function commandResetCollectibles(thePlayer, cmd, targetAccountID, theType)
    if not canManageCollectibles(thePlayer) then
        outputCustomText(thePlayer, "admin_no_permission")
        return
    end
    targetAccountID = tonumber(targetAccountID)
    if not targetAccountID then
        outputCustomText(thePlayer, "command_syntax", cmd, "[target account ID] (optional: [collectible type name])")
        return
    end
    local targetAccount = getAccountByID(targetAccountID)
    if not targetAccount then
        outputCustomText(thePlayer, "admin_invalid_account_id", tostring(targetAccount))
        return
    end
    if not theType then
        theType = "all"
    end
    resetClientCollectibles(targetAccount, theType, thePlayer)
end

function commandConfigureSpawnpoints(thePlayer, cmd, theType)
    if not canManageCollectibles(thePlayer) then
        outputCustomText(thePlayer, "admin_no_permission")
        return
    end
    if not theType then
        outputCustomText(thePlayer, "command_syntax", cmd, "[collectible type]")
        return
    end
    local collectibleTypes = getCollectibleTypes()
    local info = collectibleTypes[theType]
    if not info then
        outputCustomText(thePlayer, "admin_invalid_collectible_type", theType)
        return
    end
    triggerClientEvent(thePlayer, "collectibles:configureSpawnpoints", thePlayer, cmd, theType, info)
end

addEventHandler("collectibles:requestConfigureSpawnpoints", resourceRoot, function(theType)
    if not client then return end

    local commands = getCustomCommands()
    commandConfigureSpawnpoints(client, commands.points, theType)
end, false)

function commandManageCollectibles(thePlayer, cmd)
    if antiSpam[thePlayer] then
        outputCustomText(thePlayer, "ask_to_wait")
        return
    end
    if (goingToRestart == true) then
        outputCustomText(thePlayer, "ask_to_wait")
        return
    end
    if not canManageCollectibles(thePlayer) then
        outputCustomText(thePlayer, "admin_no_permission")
        return
    end
    antiSpam[thePlayer] = true

    local metaFileSrcs = {}
    local meta = xmlLoadFile("meta.xml", true)
    if not meta then
        antiSpam[thePlayer] = nil
        return outputChatBox("Unexpected error #1 on /"..cmd..".", thePlayer, 255, 0, 0)
    end
    local metaChildren = xmlNodeGetChildren(meta)
    if not metaChildren then
        antiSpam[thePlayer] = nil
        return outputChatBox("Unexpected error #2 on /"..cmd..".", thePlayer, 255, 0, 0)
    end
    for i=1, #metaChildren do
        local metaChild = metaChildren[i]
        if xmlNodeGetName(metaChild) == "file" then
            local src = xmlNodeGetAttribute(metaChild, "src")
            if src then
                metaFileSrcs[#metaFileSrcs + 1] = src
            end
        end
    end
    xmlUnloadFile(meta)

    local collectibleTypes = getCollectibleTypes()
    local texts = getCustomTexts()
    local commands = getCustomCommands()
    local accounts = getAccounts()
    local collectedCounts = {}
    for i=1, #accounts do
        local account = accounts[i]
        if account then
            collectedCounts[#collectedCounts + 1] = {
                accountID = getAccountID(account),
                accountName = getAccountName(account),
                counts = getCollectedCounts(account)
            }
        end
    end

    local info = {
        texts = texts,
        commands = commands,
        collectibleTypes = collectibleTypes,
        collectedCounts = collectedCounts,
        backupExists = fileExists("config.xml.backup"),
        metaFileSrcs = metaFileSrcs
    }
    
    triggerClientEvent(thePlayer, "collectibles:manage", thePlayer, info)
    
    setTimer(function()
        antiSpam[thePlayer] = nil
    end, 1000, 1)
end

local function requestUpdateConfiguration(updateNodes)
    if not client then return end

    local success, reason = updateConfiguration(updateNodes)
    if not success then
        return triggerClientEvent(client, "collectibles:manageResponse", client, false, reason, "OK")
    end

    goingToRestart = true
    setTimer(function()
        restartResource(getThisResource())
    end, 5000, 1)

    triggerClientEvent(client, "collectibles:manageResponse", client, "Changes saved successfully. The resource will now restart...\nPay attention to the server console.")
end
addEventHandler("collectibles:updateConfig", resourceRoot, requestUpdateConfiguration, false)

local function requestDeleteType(theType)
    if not client then return end

    local success, reason = deleteType(theType)
    if not success then
        return triggerClientEvent(client, "collectibles:manageResponse", client, false, reason, "OK")
    end

    goingToRestart = true
    setTimer(function()
        restartResource(getThisResource())
    end, 5000, 1)

    triggerClientEvent(client, "collectibles:manageResponse", client, "Collectible type deleted successfully. The resource will now restart...\nPay attention to the server console.")
end
addEventHandler("collectibles:deleteType", resourceRoot, requestDeleteType, false)

local function requestCreateNewType(typeInfo)
    if not client then return end

    local success, reason = createNewType(typeInfo)
    if not success then
        return triggerClientEvent(client, "collectibles:manageResponse", client, false, reason, "OK")
    end

    goingToRestart = true
    setTimer(function()
        restartResource(getThisResource())
    end, 5000, 1)

    triggerClientEvent(client, "collectibles:manageResponse", client, "Collectible type created successfully. The resource will now restart...\nPay attention to the server console.")
end
addEventHandler("collectibles:createNewType", resourceRoot, requestCreateNewType, false)

local function requestBackupConfiguration()
    if not client then return end

    local success, reason = backupConfiguration()
    if not success then
        return triggerClientEvent(client, "collectibles:manageResponse", client, false, reason, "OK")
    end

    triggerClientEvent(client, "collectibles:manageResponse", client, "Configuration backup created successfully.", false, "OK")
end
addEventHandler("collectibles:backupConfig", resourceRoot, requestBackupConfiguration, false)

local function requestRestoreConfigBackup()
    if not client then return end

    local success, reason = restoreConfigBackup()
    if not success then
        return triggerClientEvent(client, "collectibles:manageResponse", client, false, reason, "OK")
    end

    goingToRestart = true
    setTimer(function()
        restartResource(getThisResource())
    end, 5000, 1)

    triggerClientEvent(client, "collectibles:manageResponse", client, "Configuration restored successfully. The resource will now restart...\nPay attention to the server console.")
end
addEventHandler("collectibles:restoreConfigBackup", resourceRoot, requestRestoreConfigBackup, false)

local function requestGotoSpawnpoint(theType, index)
    if not client then return end

    if type(index) ~= "number" then
        return triggerClientEvent(client, "collectibles:manageResponse", client, false, "Invalid spawnpoint index.", "OK")
    end

    local collectibleTypes = getCollectibleTypes() or {}
    local info = collectibleTypes[theType]
    if not info then
        return triggerClientEvent(client, "collectibles:manageResponse", client, false, "Invalid collectible type.", "OK")
    end
    
    local spawnpoint = info.spawnpoints[index]
    if not spawnpoint then
        return triggerClientEvent(client, "collectibles:manageResponse", client, false, "Invalid spawnpoint index for '"..theType.."'", "OK")
    end

    -- Prevent the player from picking up the collectible
    setPlayerPreventPicking(client, 5000)

    local x,y,z = spawnpoint.x, spawnpoint.y, spawnpoint.z
    local interior, dimension = spawnpoint.interior, spawnpoint.dimension

    setElementPosition(client, x,y,z)
    setElementInterior(client, interior)
    setElementDimension(client, dimension)

    triggerClientEvent(client, "collectibles:manageResponse", client, "Teleported to '"..theType.."' spawnpoint #"..index..".", false, "OK")
end
addEventHandler("collectibles:gotoSpawnpoint", resourceRoot, requestGotoSpawnpoint, false)

local function requestRemoveSpawnpoint(theType, index)
    if not client then return end

    if type(index) ~= "number" then
        return triggerClientEvent(client, "collectibles:manageResponse", client, false, "Invalid spawnpoint index.", "OK")
    end

    local collectibleTypes = getCollectibleTypes() or {}
    local info = collectibleTypes[theType]
    if not info then
        return triggerClientEvent(client, "collectibles:manageResponse", client, false, "Invalid collectible type.", "OK")
    end
    
    local spawnpoint = info.spawnpoints[index]
    if not spawnpoint then
        return triggerClientEvent(client, "collectibles:manageResponse", client, false, "Invalid spawnpoint index for '"..theType.."'", "OK")
    end

    local success, reason = removeSpawnpoint(theType, index)
    if not success then
        return triggerClientEvent(client, "collectibles:manageResponse", client, false, reason, "OK")
    end

    triggerClientEvent(client, "collectibles:manageResponse", client, "'"..theType.."' spawnpoint #"..index.." removed successfully.", false, "OK")
end
addEventHandler("collectibles:removeSpawnpoint", resourceRoot, requestRemoveSpawnpoint, false)

local function requestCreateSpawnpoint(theType, model)
    if not client then return end

    local x,y,z = getElementPosition(client)
    local interior, dimension = getElementInterior(client), getElementDimension(client)

    -- Prevent the player from picking up the collectible
    setPlayerPreventPicking(client, 5000)

    local success, reason = createNewSpawnpoint(theType, model, x,y,z, interior, dimension)
    if not success then
        return triggerClientEvent(client, "collectibles:manageResponse", client, false, reason, "OK")
    end

    triggerClientEvent(client, "collectibles:manageResponse", client, "'"..theType.."' spawnpoint created successfully.", false, "OK")
end
addEventHandler("collectibles:createSpawnpoint", resourceRoot, requestCreateSpawnpoint, false)
