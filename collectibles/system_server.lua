--[[
    Author: https://github.com/Fernando-A-Rocha

    Collectibles - System (Server)

    Administrative commmands:
        - /resetcollectibles

    /!\ Unless you know what you are doing, do not edit this file. /!\
]]

-- Internal Events
addEvent("collectibles:requestCollectibles", true) -- source: always resourceRoot
addEvent("collectibles:handlePickedUp", true) -- source: always resourceRoot

-- Custom Events (for Developers)
addEvent("collectibles:onCollected", true) -- source: a player element
addEvent("collectibles:onSpawnedServer", true) -- source: always root
addEvent("collectibles:onDestroyedServer", true) -- source: always root

local clientsWaiting = {} -- initial startup
local collectibleTypes = {}
local spawnedServerCollectibles = {}

function getAccountDataNames()
    return {
        CLIENT_COUNTS = "collectibiles.client",
    }
end

--- **(Exported)**
function getCollectibleTypes()
    return collectibleTypes
end

function getConstants()
    return CONSTANTS
end

function getSpawnedServerCollectibles()
    return spawnedServerCollectibles
end

local function parseOneNode(rootChildren, targetNodeName)

    local KEY_NAMES = { "mouse1", "mouse2", "mouse3", "mouse4", "mouse5", "mouse_wheel_up", "mouse_wheel_down", "arrow_l", "arrow_u", --escape
    "arrow_r", "arrow_d", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k",
    "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "num_0", "num_1", "num_2", "num_3", "num_4", "num_5",
    "num_6", "num_7", "num_8", "num_9", "num_mul", "num_add", "num_sep", "num_sub", "num_div", "num_dec", "num_enter", "F1", "F2", "F3", "F4", "F5",
    "F6", "F7", "F8", "F9", "F10", "F11", "F12", "backspace", "tab", "lalt", "ralt", "enter", "space", "pgup", "pgdn", "end", "home",
    "insert", "delete", "lshift", "rshift", "lctrl", "rctrl", "[", "]", "pause", "capslock", "scroll", ";", ",", "-", ".", "/", "#", "\\", "=" }

    for i=1, #rootChildren do
        local node = rootChildren[i]
        if node then
            local nodeName = xmlNodeGetName(node)
            if targetNodeName == nodeName then
                if nodeName == "types" then
                    local children = xmlNodeGetChildren(node)
                    if not children then
                        return false, "Failed to get children of 'types' node."
                    end
                    for j=1, #children do
                        local child = children[j]
                        if child then
                            local childName = xmlNodeGetName(child)
                            if childName ~= "type" then
                                return false, "Invalid child node '" .. childName .. "' of 'types' node."
                            end
                            local name = xmlNodeGetAttribute(child, "name")
                            if not name then
                                return false, "Missing attribute 'name' of 'type' node."
                            end
                            if collectibleTypes[name] then
                                return false, "Duplicate collectible type '" .. name .. "'."
                            end
                            if name == "all" then
                                return false, "Collectible type name 'all' is not allowed."
                            end
                            if string.find(name, " ") then
                                return false, "Collectible type name '" .. name .. "' is not allowed - replace spaces with '_'."
                            end
                            local target = xmlNodeGetAttribute(child, "target")
                            if (not target) then
                                return false, "Missing attribute 'target' of 'type' node."
                            end
                            if not (target == "client" or target == "server") then
                                return false, "Invalid attribute 'target' of 'type' node, expected client/server."
                            end
                            local toggle_keybind = xmlNodeGetAttribute(child, "toggle_keybind") or false
                            local toggle_command = xmlNodeGetAttribute(child, "toggle_command") or false
                            if ((toggle_command or toggle_keybind) and target=="server") then
                                return false, "'toggle_keybind' or 'toggle_command' are only for client-side collectibles."
                            end
                            if toggle_command and toggle_command == "" then
                                return false, "Invalid attribute 'toggle_command' of 'type' node, can't be empty."
                            end
                            if toggle_keybind then
                                if toggle_keybind == "" then
                                    return false, "Invalid attribute 'toggle_keybind' of 'type' node, can't be empty."
                                end
                                toggle_keybind = string.lower(toggle_keybind)
                                local found = false
                                for w=1, #KEY_NAMES do
                                    if toggle_keybind == string.lower(KEY_NAMES[w]) then
                                        found = true
                                        break
                                    end
                                end
                                if not found then
                                    return false, "Invalid attribute 'toggle_keybind' of 'type' node, unknown key name."
                                end
                            end
                            local auto_load = xmlNodeGetAttribute(child, "auto_load") or false
                            if auto_load and auto_load ~= "true" and auto_load ~= "false" then
                                return false, "Invalid attribute 'auto_load' of 'type' node, expected true/false."
                            end
                            if auto_load == "true" then
                                auto_load = true
                            else
                                auto_load = false
                            end
                            local respawn_after = xmlNodeGetAttribute(child, "respawn_after") or false
                            local respawn_after_converted
                            local respawn_after_unit = xmlNodeGetAttribute(child, "respawn_after_unit") or false
                            if (target=="client" and respawn_after) then
                                respawn_after = tonumber(respawn_after)
                                if (not respawn_after) or (respawn_after < 0) then
                                    return false, "Invalid attribute 'respawn_after' of 'type' node - must be a number greater than 0."
                                end
                                if not (respawn_after_unit == "seconds"
                                or respawn_after_unit == "minutes"
                                or respawn_after_unit == "hours"
                                or respawn_after_unit == "days"
                                or respawn_after_unit == "weeks") then
                                    return false, "Invalid attribute 'respawn_after_unit' of 'type' node - must be seconds/minutes/hours/days/weeks."
                                end
                                -- convert to seconds
                                respawn_after_converted = respawn_after
                                if respawn_after_unit == "minutes" then
                                    respawn_after_converted = respawn_after_converted * 60
                                elseif respawn_after_unit == "hours" then
                                    respawn_after_converted = respawn_after_converted * 60 * 60
                                elseif respawn_after_unit == "days" then
                                    respawn_after_converted = respawn_after_converted * 60 * 60 * 24
                                elseif respawn_after_unit == "weeks" then
                                    respawn_after_converted = respawn_after_converted * 60 * 60 * 24 * 7
                                end
                            end
                            collectibleTypes[name] = {
                                target = target,
                                auto_load = auto_load,

                                -- client only:
                                toggle_keybind = toggle_keybind,
                                toggle_command = toggle_command,
                                respawn_after = respawn_after_converted,
                                respawn_after_nonconverted = respawn_after,
                                respawn_after_unit = respawn_after_unit,
                            }
                        end
                    end
                elseif nodeName == "actions" then
                    local children = xmlNodeGetChildren(node)
                    if not children then
                        return false, "Failed to get children of 'actions' node."
                    end
                    for j=1, #children do
                        local child = children[j]
                        if child then
                            local childName = xmlNodeGetName(child)
                            if childName ~= "action" then
                                return false, "Invalid child node '" .. childName .. "' of 'actions' node."
                            end
                            local theType = xmlNodeGetAttribute(child, "type")
                            if not theType then
                                return false, "Missing attribute 'type' of 'action' node."
                            end
                            local collectibleType = collectibleTypes[theType]
                            if not collectibleType then
                                return false, "Invalid type '" .. theType .. "' of 'action' node."
                            end
                            local on = xmlNodeGetAttribute(child, "on")
                            if not on then
                                return false, "Missing attribute 'on' of 'action' node."
                            end
                            if not (on == "collect_one" or on == "collect_last") then
                                return false, "Invalid attribute 'on' of 'action' node."
                            end
                            local sound = xmlNodeGetAttribute(child, "sound") or false
                            local sound_volume = xmlNodeGetAttribute(child, "sound_volume")
                            if sound then
                                if not fileExists(sound) then
                                    return false, "Invalid attribute 'sound' of 'action' node - file does not exist."
                                end
                                sound_volume = tonumber(sound_volume)
                                if (not sound_volume) or (sound_volume < 0) then
                                    return false, "Invalid attribute 'sound_volume' of 'action' node - must be a number greater than 0."
                                end
                            end
                            local reward_money = xmlNodeGetAttribute(child, "reward_money") or false
                            if reward_money then
                                reward_money = tonumber(reward_money)
                                if (not reward_money) or (reward_money < 0) then
                                    return false, "Invalid attribute 'reward_money' of 'action' node - must be a number greater than 0."
                                end
                            end
                            collectibleTypes[theType][on] = {
                                sound = sound,
                                sound_volume = sound_volume,
                                reward_money = reward_money,
                            }
                        end
                    end
                elseif nodeName == "spawnpoints" then
                    local children = xmlNodeGetChildren(node)
                    if not children then
                        return false, "Failed to get children of 'spawnpoints' node."
                    end
                    for j=1, #children do
                        local child = children[j]
                        if child then
                            local childName = xmlNodeGetName(child)
                            if childName ~= "spawnpoint" then
                                return false, "Invalid child node '" .. childName .. "' of 'spawnpoints' node."
                            end
                            local theType = xmlNodeGetAttribute(child, "type")
                            if not theType then
                                return false, "Missing attribute 'type' of 'spawnpoint' node."
                            end
                            local id = xmlNodeGetAttribute(child, "id")
                            id = tonumber(id)
                            if (not id) or (id < 0) then
                                return false, "Invalid attribute 'id' of 'spawnpoint' node - must be a number greater than 0."
                            end
                            local x = xmlNodeGetAttribute(child, "x")
                            if not x then
                                return false, "Missing attribute 'x' of 'spawnpoint' node."
                            end
                            x = tonumber(x)
                            if (not x) then
                                return false, "Invalid attribute 'x' of 'spawnpoint' node - must be a number."
                            end
                            local y = xmlNodeGetAttribute(child, "y")
                            if not y then
                                return false, "Missing attribute 'y' of 'spawnpoint' node."
                            end
                            y = tonumber(y)
                            if (not y) then
                                return false, "Invalid attribute 'y' of 'spawnpoint' node - must be a number."
                            end
                            local z = xmlNodeGetAttribute(child, "z")
                            if not z then
                                return false, "Missing attribute 'z' of 'spawnpoint' node."
                            end
                            z = tonumber(z)
                            if (not z) then
                                return false, "Invalid attribute 'z' of 'spawnpoint' node - must be a number."
                            end
                            local interior = xmlNodeGetAttribute(child, "interior") or 0
                            interior = tonumber(interior)
                            if (not interior) or (interior < 0) then
                                return false, "Invalid attribute 'interior' of 'spawnpoint' node - must be a number greater than 0."
                            end
                            local dimension = xmlNodeGetAttribute(child, "dimension") or 0
                            dimension = tonumber(dimension)
                            if (not dimension) or (dimension < 0) then
                                return false, "Invalid attribute 'dimension' of 'spawnpoint' node - must be a number greater than 0."
                            end
                            local model = xmlNodeGetAttribute(child, "model")
                            if not model then
                                return false, "Missing attribute 'model' of 'spawnpoint' node."
                            end
                            model = tonumber(model)
                            if (not model) or (model < 0) then
                                return false, "Invalid attribute 'model' of 'spawnpoint' node - must be a number greater than 0."
                            end
                            local testPickup = createPickup(x, y, z, 3, model)
                            if not testPickup then
                                destroyElement(testPickup)
                                return false, "Invalid attribute 'model' of 'spawnpoint' node - invalid object model ID."
                            end
                            destroyElement(testPickup)
                            for theType2, info in pairs(collectibleTypes) do
                                if info.spawnpoints then
                                    for w=1, #info.spawnpoints do
                                        local spawnpoint = info.spawnpoints[w]
                                        if spawnpoint and spawnpoint.x == x and spawnpoint.y == y and spawnpoint.z == z then
                                            return false, "Duplicate spawnpoint at position " .. x .. ", " .. y .. ", " .. z .. "."
                                        end
                                    end
                                end
                            end
                            if not collectibleTypes[theType].spawnpoints then
                                collectibleTypes[theType].spawnpoints = {}
                            end
                            for w=1, #collectibleTypes[theType].spawnpoints do
                                local spawnpoint = collectibleTypes[theType].spawnpoints[w]
                                if spawnpoint and spawnpoint.spID == id then
                                    return false, "Duplicate spawnpoint ID '" .. id .. "' for type '" .. theType .. "'."
                                end
                            end
                            local newIndex = #collectibleTypes[theType].spawnpoints + 1
                            collectibleTypes[theType].spawnpoints[newIndex] = {
                                spID = id,
                                x = x,
                                y = y,
                                z = z,
                                interior = interior,
                                dimension = dimension,
                                model = model,
                            }
                        end
                    end
                end
            end
        end
    end
    return true
end

local function commandSpawnCollectibles(thePlayer, cmd, theType)
    if not canAdminCollectibles(thePlayer) then
        oct(thePlayer, gct("You don't have permission to do this."))
        return
    end
    if not theType then
        oct(thePlayer, gct("SYNTAX: /%s %s", cmd, gct("[collectible type name]")))
        return
    end
    spawnCollectibles(theType, thePlayer)
end

local function commandDestroyCollectibles(thePlayer, cmd, theType)
    if not canAdminCollectibles(thePlayer) then
        oct(thePlayer, gct("You don't have permission to do this."))
        return
    end
    if not theType then
        oct(thePlayer, gct("SYNTAX: /%s %s", cmd, gct("[collectible type name]")))
        return
    end
    destroyCollectibles(theType, thePlayer)
end

local function commandResetCollectibles(thePlayer, cmd, targetAccountID, theType)
    if not canAdminCollectibles(thePlayer) then
        oct(thePlayer, gct("You don't have permission to do this."))
        return
    end
    targetAccountID = tonumber(targetAccountID)
    if not targetAccountID then
        oct(thePlayer, gct("SYNTAX: /%s %s", cmd, gct("[target account ID]")..gct("optional:")..gct("[collectible type name]")))
        return
    end
    local targetAccount = getAccountByID(targetAccountID)
    if not targetAccount then
        oct(thePlayer, gct("User account ID %s does not exist.", tostring(targetAccount)))
        return
    end
    if not theType then
        theType = "all"
    end
    resetClientCollectibles(targetAccount, theType, thePlayer)
end

local function commandCreateSpawnpoint(thePlayer, cmd, theType, model)
    if not canAdminCollectibles(thePlayer) then
        oct(thePlayer, gct("You don't have permission to do this."))
        return
    end
    model = tonumber(model)
    if not theType or not model then
        oct(thePlayer, gct("SYNTAX: /%s %s", cmd, gct("[collectible type name]").." "..gct("[pickup object model ID]")))
        return
    end
    if not collectibleTypes[theType] then
        oct(thePlayer, gct("Collectible type '%s' does not exist.", theType))
        return
    end
    if not isDefaultObjectID(model) then
        oct(thePlayer, gct("Model ID %s is not a valid object ID.", tostring(model)))
        return
    end
    local x,y,z = getElementPosition(thePlayer)
    local interior, dimension = getElementInterior(thePlayer), getElementDimension(thePlayer)
    setPlayerPreventPicking(thePlayer, 5000)
    local newSpID, reason = createNewSpawnpoint(theType, model, x,y,z, interior, dimension)
    if not newSpID then
        oct(thePlayer, gct("Error: %s", reason))
        return
    end
    oct(thePlayer, gct("You have created a new spawnpoint with ID %s (%s).", tostring(newSpID), (string.gsub(theType, "_", " "))))
end

local function commandRemoveSpawnpoint(thePlayer, cmd, theType, spID)
    if not canAdminCollectibles(thePlayer) then
        oct(thePlayer, gct("You don't have permission to do this."))
        return
    end
    spID = tonumber(spID)
    if not theType or not spID then
        oct(thePlayer, gct("SYNTAX: /%s %s", cmd, gct("[collectible type name]").." "..gct("[spawnpoint ID]")))
        return
    end
    if not collectibleTypes[theType] then
        oct(thePlayer, gct("Collectible type '%s' does not exist.", theType))
        return
    end
    if #collectibleTypes[theType].spawnpoints == 0 then
        oct(thePlayer, gct("Collectible type '%s' has %s spawnpoints defined.", (string.gsub(theType, "_", " ")), 0))
        return
    end
    for i=1, #collectibleTypes[theType].spawnpoints do
        local spawnpoint = collectibleTypes[theType].spawnpoints[i]
        if spawnpoint and spawnpoint.spID == spID then
            local success, reason = removeSpawnpoint(theType, spID)
            if not success then
                oct(thePlayer, gct("Error: %s", reason))
                return
            end
            oct(thePlayer, gct("You have deleted spawnpoint ID %s (%s).", tostring(spID), (string.gsub(theType, "_", " "))))
            return
        end
    end
    oct(thePlayer, gct("Collectible type '%s' doesn't have a spawnpoint with ID %s.", (string.gsub(theType, "_", " ")), spID))
end

--- Validates all custom settings
--
--- returns true if successful, false + error message otherwise.
local function parseCustomSettings()

    --[[
        CUSTOM FUNCTIONS
    --]]
    if type(canAdminCollectibles) ~= "function" then
        return false, "Failed to parse custom settings - canAdminCollectibles is not a function."
    end
    if type(canCollectPickup) ~= "function" then
        return false, "Failed to parse custom settings - canCollectPickup is not a function."
    end

    --[[
        CONSTANTS TABLE
    --]]
    if type(CONSTANTS) ~= "table" then
        return false, "Failed to parse constants - CONSTANTS is not a table."
    end

    -- COMMANDS
    if type(CONSTANTS.COMMANDS) ~= "table" then
        return false, "Failed to parse constants - CONSTANTS.COMMANDS is not a table."
    end

    local commands = CONSTANTS.COMMANDS
    if type(commands.SPAWN) ~= "string" then
        return false, "Failed to parse constants - CONSTANTS.COMMANDS.SPAWN is not a string."
    end
    addCommandHandler(commands.SPAWN, commandSpawnCollectibles, false, false)

    if type(commands.DESTROY) ~= "string" then
        return false, "Failed to parse constants - CONSTANTS.COMMANDS.DESTROY is not a string."
    end
    addCommandHandler(commands.DESTROY, commandDestroyCollectibles, false, false)

    if type(commands.RESETPLAYER) ~= "string" then
        return false, "Failed to parse constants - CONSTANTS.COMMANDS.RESETPLAYER is not a string."
    end
    addCommandHandler(commands.RESETPLAYER, commandResetCollectibles, false, false)

    if type(commands.CREATESPAWN) ~= "string" then
        return false, "Failed to parse constants - CONSTANTS.COMMANDS.CREATESPAWN is not a string."
    end
    addCommandHandler(commands.CREATESPAWN, commandCreateSpawnpoint, false, false)

    if type(commands.REMOVESPAWN) ~= "string" then
        return false, "Failed to parse constants - CONSTANTS.COMMANDS.REMOVESPAWN is not a string."
    end
    addCommandHandler(commands.REMOVESPAWN, commandRemoveSpawnpoint, false, false)

    -- Optional Commands
    if (CONFIG_EDITOR_LOADED) then
        if type(commands.SPAWNPOINTS) ~= "string" then
            return false, "Failed to parse constants - CONSTANTS.COMMANDS.SPAWNPOINTS is not a string."
        end
        addCommandHandler(commands.SPAWNPOINTS, commandConfigureSpawnpoints, false, false)

        if type(commands.EDITOR) ~= "string" then
            return false, "Failed to parse constants - CONSTANTS.COMMANDS.EDITOR is not a string."
        end
        addCommandHandler(commands.EDITOR, commandOpenEditor, false, false)
    end

    -- Misc constants
    if type(CONSTANTS.COLLECTIBLES_FILE) ~= "string" then
        return false, "Failed to parse constants - CONSTANTS.COLLECTIBLES_FILE is not a string."
    end
    if type(CONSTANTS.STRINGS_FILE) ~= "string" then
        return false, "Failed to parse constants - CONSTANTS.STRINGS_FILE is not a string."
    end
    if type(CONSTANTS.BACKUPS_DIRECTORY) ~= "string" then
        return false, "Failed to parse constants - CONSTANTS.BACKUPS_DIRECTORY is not a string."
    end

    -- STRINGS
    CONSTANTS.STRINGS = {}
    local stringsJsonF
    local stringsJson
    if not fileExists(CONSTANTS.STRINGS_FILE) then
        stringsJsonF = fileCreate(CONSTANTS.STRINGS_FILE)
        if not stringsJsonF then
            outputDebugMsg("Failed to parse "..CONSTANTS.STRINGS_FILE.." - couldn't create file.", "ERROR")
            stringsJsonF = nil
        else
            stringsJson = toJSON({})
            fileWrite(stringsJsonF, stringsJson)
            fileClose(stringsJsonF)
            outputDebugMsg("Created "..CONSTANTS.STRINGS_FILE.." file.", "INFO")
        end
    else
        stringsJsonF = fileOpen(CONSTANTS.STRINGS_FILE, true)
        if not stringsJsonF then
            outputDebugMsg("Failed to parse "..CONSTANTS.STRINGS_FILE.." - couldn't open file.", "ERROR")
            stringsJsonF = nil
        else
            stringsJson = fileRead(stringsJsonF, fileGetSize(stringsJsonF))
            fileClose(stringsJsonF)
        end
    end
    if stringsJson then
        local strings = fromJSON(stringsJson)
        if strings then
            local c = 0
            for name, v in pairs(strings) do
                if type(name) ~= "string" then
                    outputDebugMsg("Failed to parse "..CONSTANTS.STRINGS_FILE.." - "..name.." is not a string.", "ERROR")
                elseif type(v) ~= "table" then
                    outputDebugMsg("Failed to parse "..CONSTANTS.STRINGS_FILE.." - "..name.." is not a table.", "ERROR")
                elseif type(v.value) ~= "string" then
                    outputDebugMsg("Failed to parse "..CONSTANTS.STRINGS_FILE.." - "..name..".value is not a string.", "ERROR")
                else
                    if (v.rgb) ~= nil then
                        if not (type(v.rgb[1])=="number" and type(v.rgb[2])=="number" and type(v.rgb[3])=="number") then
                            outputDebugMsg("Failed to parse "..CONSTANTS.STRINGS_FILE.." - "..name..".rgb is not a table of 3 numbers.", "ERROR")
                        elseif v.rgb[1] < 0 or v.rgb[1] > 255 or v.rgb[2] < 0 or v.rgb[2] > 255 or v.rgb[3] < 0 or v.rgb[3] > 255 then
                            outputDebugMsg("Failed to parse "..CONSTANTS.STRINGS_FILE.." - "..name..".rgb is not a table of 3 numbers between 0 and 255.", "ERROR")
                        end
                    end
                    CONSTANTS.STRINGS[name] = {value = v.value, rgb = (v.rgb or nil)}
                    c = c + 1
                end
            end
            outputDebugMsg("Parsed "..c.." strings from "..CONSTANTS.STRINGS_FILE..".", "SUCCESS")
        else
            outputDebugMsg("Failed to parse "..CONSTANTS.STRINGS_FILE.." - invalid format. Use a JSON validator.", "ERROR")
        end
    end

    return true
end

--- Loads the configuration file and parses it
--
-- Errors are usually caused by incorrectly formatted XML file (caused by editing it manually) and file IO operations.
local function loadConfiguration()

    local config = xmlLoadFile(CONSTANTS.COLLECTIBLES_FILE)
    if not config then
        return false, "Failed to load file "..CONSTANTS.COLLECTIBLES_FILE.."."
    end

    local children = xmlNodeGetChildren(config)
    if not children then
        xmlUnloadFile(config)
        return false, "Failed to get children of "..CONSTANTS.COLLECTIBLES_FILE.."."
    end

    local success, reason, theType = parseOneNode(children, "types")
    if not success then
        xmlUnloadFile(config)
        return false, "Failed to parse <types>: " .. reason
    end
    success, reason = parseOneNode(children, "actions")
    if not success then
        xmlUnloadFile(config)
        return false, "Failed to parse <actions>: " .. reason
    end
    for theType2, info2 in pairs(collectibleTypes) do
        if not info2.collect_one then
            xmlUnloadFile(config)
            return false, "Missing action 'collect_one' for type '" .. theType2 .. "'."
        end
        if not info2.collect_last then
            xmlUnloadFile(config)
            return false, "Missing action 'collect_last' for type '" .. theType2 .. "'."
        end
    end
    success, reason = parseOneNode(children, "spawnpoints")
    if not success then
        xmlUnloadFile(config)
        return false, "Failed to parse <spawnpoints>: " .. reason
    end
    for theType2, info2 in pairs(collectibleTypes) do
        if not info2.spawnpoints then
            collectibleTypes[theType2].spawnpoints = {}
        end
        collectibleTypes[theType2].total = #collectibleTypes[theType2].spawnpoints
    end

    xmlUnloadFile(config)
    return true
end

function backupConfiguration(backupPath)
    if not fileCopy(CONSTANTS.COLLECTIBLES_FILE, backupPath, true) then
        return false, "Failed to copy file "..CONSTANTS.COLLECTIBLES_FILE.." to '"..backupPath.."' - check permissions."
    end
    return true
end

function restoreConfigBackup(backupPath)
    if not fileExists(backupPath) then
        return false, "File '" .. backupPath .. "' does not exist."
    end
    local oldPath = backupPath .. ".old"
    if not fileCopy(CONSTANTS.COLLECTIBLES_FILE, oldPath, true) then -- Backup to .old
        return false, "Failed to copy file "..CONSTANTS.COLLECTIBLES_FILE.." to '"..oldPath.."' - check permissions."
    end
    if not fileCopy(backupPath, CONSTANTS.COLLECTIBLES_FILE, true) then -- Overwrite
        return false, "Failed to copy file '"..backupPath.."' to "..CONSTANTS.COLLECTIBLES_FILE.." - check permissions."
    end
    return true
end

function duplicateConfigBackup(oldPath, newPath)
    if not fileExists(oldPath) then
        return false, "File '"..oldPath.."' does not exist."
    end
    if fileExists(newPath) then
        return false, "File '" .. newPath .. "' already exists, will not override."
    end
    if not fileCopy(oldPath, newPath) then
        return false, "Failed to copy file '"..oldPath.."' to '"..newPath.."' - check permissions."
    end
    return true
end

local function findNode(theChildren, nodeName, attributeNames)
    for i=1, #theChildren do
        local child = theChildren[i]
        if xmlNodeGetName(child) == nodeName then
            local nodeChildren = xmlNodeGetChildren(child)
            if not nodeChildren then
                return false, "Failed to get children of '" .. nodeName .. "' in "..CONSTANTS.COLLECTIBLES_FILE.."."
            end
            for j=1, #nodeChildren do
                local nodeChild = nodeChildren[j]
                if nodeChild then
                    local matches = true
                    for attrName, withAttrName in pairs(attributeNames) do
                        if xmlNodeGetAttribute(nodeChild, attrName) ~= withAttrName then
                            matches = false
                            break
                        end
                    end
                    if matches then
                        return nodeChild
                    end
                end
            end
        end
    end
    return false, "Failed to find node '" .. nodeName .. "/" .. inspect(attributeNames) .. "' in "..CONSTANTS.COLLECTIBLES_FILE.."."
end

function updateConfiguration(updateNodes, updateStrings)
    assert(type(updateNodes) == "table", "Bad argument @ updateConfiguration (expected table at argument 1, got " .. type(updateNodes) .. ")")
    assert(type(updateStrings) == "table", "Bad argument @ updateConfiguration (expected table at argument 2, got " .. type(updateStrings) .. ")")

    local config = xmlLoadFile(CONSTANTS.COLLECTIBLES_FILE)
    if not config then
        return false, "Failed to load file "..CONSTANTS.COLLECTIBLES_FILE.."."
    end

    local children = xmlNodeGetChildren(config)
    if not children then
        xmlUnloadFile(config)
        return false, "Failed to get children of "..CONSTANTS.COLLECTIBLES_FILE.."."
    end

    local updatedTypeNames = {} -- old => new
    for settingType, list in pairs(updateNodes) do
        for name, info in pairs(list) do
            if type(info.attributes)=="table" then
                for attrName, attrValue in pairs(info.attributes) do
                    if settingType == "types" and attrName == "name" then
                        updatedTypeNames[name] = attrValue
                    end
                end
            end
        end
    end

    for settingType, list in pairs(updateNodes) do
        for name, info in pairs(list) do
            local attributeNames = info.attributeNames
            if type(attributeNames)=="table" then
                local node, failFindReason = findNode(children, settingType, attributeNames)
                if not node then
                    xmlUnloadFile(config)
                    return false, failFindReason
                end
                if type(info.value)=="string" then
                    xmlNodeSetValue(node, info.value)
                end
                if type(info.attributes)=="table" then
                    for attrName, attrValue in pairs(info.attributes) do
                        if attrValue == false then
                            xmlNodeSetAttribute(node, tostring(attrName), nil)
                        else
                            xmlNodeSetAttribute(node, tostring(attrName), tostring(attrValue))
                        end
                    end
                end
            end
        end
    end

    children = xmlNodeGetChildren(config)
    if not children then
        xmlUnloadFile(config)
        return false, "Failed to get children of "..CONSTANTS.COLLECTIBLES_FILE.."."
    end

    for i=1, #children do
        local child = children[i]
        if xmlNodeGetName(child) == "actions" or xmlNodeGetName(child) == "spawnpoints" then
            local nodeChildren = xmlNodeGetChildren(child)
            if not nodeChildren then
                xmlUnloadFile(config)
                return false, "Failed to get children of '" .. xmlNodeGetName(child) .. "' in "..CONSTANTS.COLLECTIBLES_FILE.."."
            end
            for j=1, #nodeChildren do
                local nodeChild = nodeChildren[j]
                local typeName = xmlNodeGetAttribute(nodeChild, "type")
                if typeName and updatedTypeNames[typeName] then
                    xmlNodeSetAttribute(nodeChild, "type", updatedTypeNames[typeName])
                end
            end
        end
    end

    if not xmlSaveFile(config) then
        xmlUnloadFile(config)
        return false, "Failed to save file "..CONSTANTS.COLLECTIBLES_FILE.."."
    end

    xmlUnloadFile(config)

    for name, v in pairs(updateStrings) do
        if type(name) ~= "string" then
            return false, "updateStrings table has non-string key."
        end
        if type(v) ~= "table" then
            return false, "updateStrings table has non-table value."
        end
        if type(v.value) ~= "string" then
            return false, "updateStrings - "..name..".value is not a string."
        end
        if (v.rgb) ~= nil then
            if not (type(v.rgb[1])=="number" and type(v.rgb[2])=="number" and type(v.rgb[3])=="number") then
                return false, "updateStrings - "..name..".rgb is not a table of 3 numbers."
            end
            if v.rgb[1] < 0 or v.rgb[1] > 255 or v.rgb[2] < 0 or v.rgb[2] > 255 or v.rgb[3] < 0 or v.rgb[3] > 255 then
                return false, "updateStrings - "..name..".rgb is not a table of 3 numbers between 0 and 255."
            end
        end
        CONSTANTS.STRINGS[name] = {value = v.value, rgb = (v.rgb or nil)}
    end

    local stringsJsonF = fileOpen(CONSTANTS.STRINGS_FILE)
    if not stringsJsonF then
        return false, "Failed to open file: "..CONSTANTS.STRINGS_FILE
    end
    fileWrite(stringsJsonF, toJSON(CONSTANTS.STRINGS, false, "tabs"))
    fileClose(stringsJsonF)

    return true
end

function deleteType(theType)
    assert(type(theType) == "string", "Bad argument @ deleteType (string expected, got " .. type(theType) .. ")")
    local info = collectibleTypes[theType]
    if not info then
        return false, "Failed to delete type '" .. theType .. "' - type does not exist."
    end

    local config = xmlLoadFile(CONSTANTS.COLLECTIBLES_FILE)
    if not config then
        return false, "Failed to load file "..CONSTANTS.COLLECTIBLES_FILE.."."
    end

    local children = xmlNodeGetChildren(config)
    if not children then
        xmlUnloadFile(config)
        return false, "Failed to get children of "..CONSTANTS.COLLECTIBLES_FILE.."."
    end

    -- Find the necessary node
    local typesNode, actionsNode, spawnpointsNode
    for i=1, #children do
        local child = children[i]
        if xmlNodeGetName(child) == "types" then
            typesNode = child
        elseif xmlNodeGetName(child) == "actions" then
            actionsNode = child
        elseif xmlNodeGetName(child) == "spawnpoints" then
            spawnpointsNode = child
        end
    end

    if not typesNode then
        xmlUnloadFile(config)
        return false, "Failed to find node 'types' in "..CONSTANTS.COLLECTIBLES_FILE.."."
    end
    if not actionsNode then
        xmlUnloadFile(config)
        return false, "Failed to find node 'actions' in "..CONSTANTS.COLLECTIBLES_FILE.."."
    end
    if not spawnpointsNode then
        xmlUnloadFile(config)
        return false, "Failed to find node 'spawnpoints' in "..CONSTANTS.COLLECTIBLES_FILE.."."
    end

    local typesChildren = xmlNodeGetChildren(typesNode)
    if not typesChildren then
        xmlUnloadFile(config)
        return false, "Failed to get children of 'types' in "..CONSTANTS.COLLECTIBLES_FILE.."."
    end

    local actionsChildren = xmlNodeGetChildren(actionsNode)
    if not actionsChildren then
        xmlUnloadFile(config)
        return false, "Failed to get children of 'actions' in "..CONSTANTS.COLLECTIBLES_FILE.."."
    end

    local spawnpointsChildren = xmlNodeGetChildren(spawnpointsNode)
    if not spawnpointsChildren then
        xmlUnloadFile(config)
        return false, "Failed to get children of 'spawnpoints' in "..CONSTANTS.COLLECTIBLES_FILE.."."
    end

    local typeNode = nil
    local actionNodes, spawnpointNodes = {}, {}
    for i=1, #typesChildren do
        local child = typesChildren[i]
        if xmlNodeGetName(child) == "type" then
            local name = xmlNodeGetAttribute(child, "name")
            if name == theType then
                typeNode = child
                break
            end
        end
    end
    if not typeNode then
        xmlUnloadFile(config)
        return false, "Failed to find node 'type' with attribute 'name' = '" .. theType .. "' in "..CONSTANTS.COLLECTIBLES_FILE.."."
    end

    for i=1, #actionsChildren do
        local child = actionsChildren[i]
        if xmlNodeGetName(child) == "action" then
            local typeName = xmlNodeGetAttribute(child, "type")
            if typeName == theType then
                actionNodes[#actionNodes+1] = child
            end
        end
    end
    if #actionNodes ~= 2 then
        xmlUnloadFile(config)
        return false, "Failed to find 2 'action' nodes with attribute 'type' = '" .. theType .. "' in "..CONSTANTS.COLLECTIBLES_FILE.."."
    end

    for i=1, #spawnpointsChildren do
        local child = spawnpointsChildren[i]
        if xmlNodeGetName(child) == "spawnpoint" then
            local typeName = xmlNodeGetAttribute(child, "type")
            if typeName == theType then
                spawnpointNodes[#spawnpointNodes+1] = child
            end
        end
    end

    -- Delete the nodes
    xmlDestroyNode(typeNode)
    for i=1, #actionNodes do
        xmlDestroyNode(actionNodes[i])
    end
    for i=1, #spawnpointNodes do
        if spawnpointNodes[i] then
            xmlDestroyNode(spawnpointNodes[i])
        end
    end

    if info.target == "client" then

        -- reset all accounts' collected counts of this type
        local accounts = getAccounts()
        local collectedCounts = {}
        for i=1, #accounts do
            local account = accounts[i]
            if account then
                local dataName = getAccountDataNames().CLIENT_COUNTS
                local data = getAccountData(account, dataName)
                if not data then
                    data = {}
                else
                    data = fromJSON(data) or {}
                end
                data[theType] = nil
                setAccountData(account, dataName, toJSON(data))
            end
        end
    end

    if not xmlSaveFile(config) then
        xmlUnloadFile(config)
        return false, "Failed to save file "..CONSTANTS.COLLECTIBLES_FILE.."."
    end

    xmlUnloadFile(config)
    return true
end

function createNewType(typeInfo)
    assert(type(typeInfo) == "table", "Bad argument @ createNewType (table expected, got " .. type(typeInfo) .. ")")

    local config = xmlLoadFile(CONSTANTS.COLLECTIBLES_FILE)
    if not config then
        return false, "Failed to load file "..CONSTANTS.COLLECTIBLES_FILE.."."
    end

    local children = xmlNodeGetChildren(config)
    if not children then
        xmlUnloadFile(config)
        return false, "Failed to get children of "..CONSTANTS.COLLECTIBLES_FILE.."."
    end

    -- Verify type info

    local newName = typeInfo.name
    if type(newName) ~= "string" then
        xmlUnloadFile(config)
        return false, "Failed to create new type - no name specified."
    end

    if type(typeInfo.auto_load) ~= "string" then
        xmlUnloadFile(config)
        return false, "Failed to create new type - no auto_load specified."
    end

    if type(typeInfo.target) ~= "string" then
        xmlUnloadFile(config)
        return false, "Failed to create new type - no target specified."
    end

    if type(typeInfo.actions) ~= "table" then
        xmlUnloadFile(config)
        return false, "Failed to create new type - no actions specified."
    end

    if type(typeInfo.actions.collect_one) ~= "table" then
        xmlUnloadFile(config)
        return false, "Failed to create new type - no collect_one actions specified."
    end

    if type(typeInfo.actions.collect_last) ~= "table" then
        xmlUnloadFile(config)
        return false, "Failed to create new type - no collect_last actions specified."
    end

    -- Check if type with that name already exists
    if findNode(children, "types", {name=newName}) then
        xmlUnloadFile(config)
        return false, "Failed to create new type - type with name '" .. newName .. "' already exists."
    end

    -- Find the necessary node
    local typesNode, actionsNode
    for i=1, #children do
        local child = children[i]
        if xmlNodeGetName(child) == "types" then
            typesNode = child
        elseif xmlNodeGetName(child) == "actions" then
            actionsNode = child
        end
    end

    if not typesNode then
        xmlUnloadFile(config)
        return false, "Failed to find node 'types' in "..CONSTANTS.COLLECTIBLES_FILE.."."
    end
    if not actionsNode then
        xmlUnloadFile(config)
        return false, "Failed to find node 'actions' in "..CONSTANTS.COLLECTIBLES_FILE.."."
    end

    -- Create new type node

    local newTypeNode = xmlCreateChild(typesNode, "type")
    if not newTypeNode then
        xmlUnloadFile(config)
        return false, "Failed to create new type node."
    end

    xmlNodeSetAttribute(newTypeNode, "name", newName)
    xmlNodeSetAttribute(newTypeNode, "auto_load", typeInfo.auto_load)
    xmlNodeSetAttribute(newTypeNode, "target", typeInfo.target)

    if typeInfo.respawn_after ~= nil then
        if type(typeInfo.respawn_after) ~= "string" then
            xmlUnloadFile(config)
            return false, "Failed to create new type - respawn_after must be a string."
        end
        if type(typeInfo.respawn_after_unit) ~= "string" then
            xmlUnloadFile(config)
            return false, "Failed to create new type - respawn_after_unit must be a string."
        end
        xmlNodeSetAttribute(newTypeNode, "respawn_after", typeInfo.respawn_after)
        xmlNodeSetAttribute(newTypeNode, "respawn_after_unit", typeInfo.respawn_after_unit)
    end
    if typeInfo.toggle_command ~= nil then
        if type(typeInfo.toggle_command) ~= "string" then
            xmlUnloadFile(config)
            return false, "Failed to create new type - toggle_command must be a string."
        end
        xmlNodeSetAttribute(newTypeNode, "toggle_command", typeInfo.toggle_command)
    end
    if typeInfo.toggle_key_bind ~= nil then
        if type(typeInfo.toggle_key_bind) ~= "string" then
            xmlUnloadFile(config)
            return false, "Failed to create new type - toggle_key_bind must be a string."
        end
        xmlNodeSetAttribute(newTypeNode, "toggle_key_bind", typeInfo.toggle_key_bind)
    end

    -- Create 2 action nodes

    local newActionNodeOne = xmlCreateChild(actionsNode, "action")
    if not newActionNodeOne then
        xmlUnloadFile(config)
        return false, "Failed to create new action node."
    end

    xmlNodeSetAttribute(newActionNodeOne, "type", newName)
    xmlNodeSetAttribute(newActionNodeOne, "on", "collect_one")

    if typeInfo.actions.collect_one.sound ~= nil then
        if type(typeInfo.actions.collect_one.sound) ~= "string" then
            xmlUnloadFile(config)
            return false, "Failed to create new type - collect_one sound must be a string."
        end
        if type(typeInfo.actions.collect_one.sound_volume) ~= "string" then
            xmlUnloadFile(config)
            return false, "Failed to create new type - collect_one sound_volume must be a string."
        end
        xmlNodeSetAttribute(newActionNodeOne, "sound_volume", typeInfo.actions.collect_one.sound_volume)
    end

    local newActionNodeAll = xmlCreateChild(actionsNode, "action")
    if not newActionNodeAll then
        xmlUnloadFile(config)
        return false, "Failed to create new action node."
    end

    xmlNodeSetAttribute(newActionNodeAll, "type", newName)
    xmlNodeSetAttribute(newActionNodeAll, "on", "collect_last")

    if typeInfo.actions.collect_last.sound ~= nil then
        if type(typeInfo.actions.collect_last.sound) ~= "string" then
            xmlUnloadFile(config)
            return false, "Failed to create new type - collect_last sound must be a string."
        end
        if type(typeInfo.actions.collect_last.sound_volume) ~= "string" then
            xmlUnloadFile(config)
            return false, "Failed to create new type - collect_last sound_volume must be a string."
        end
        xmlNodeSetAttribute(newActionNodeAll, "sound_volume", typeInfo.actions.collect_last.sound_volume)
    end

    if not xmlSaveFile(config) then
        xmlUnloadFile(config)
        return false, "Failed to save file "..CONSTANTS.COLLECTIBLES_FILE.."."
    end

    xmlUnloadFile(config)
    return true
end

local function createOnePickup(theType, spID, spawnpoint)
    local pickup = createPickup(spawnpoint.x, spawnpoint.y, spawnpoint.z, 3, spawnpoint.model)
    if not pickup then
        outputInfoMessage("Failed to create pickup for type '" .. theType .. "' at spawnpoint " .. (spID) .. ".", "ERROR")
        return false
    end
    setElementInterior(pickup, spawnpoint.interior)
    setElementDimension(pickup, spawnpoint.dimension)
    spawnedServerCollectibles[pickup] = {
        type = theType,
        spID = spID,
    }
    return pickup
end

--- **(Exported)**
function spawnCollectibles(theType, thePlayer)
    assert(type(theType) == "string", "Bad argument @ spawnCollectibles [expected string at argument 1, got " .. type(theType) .. "]")
    local info = collectibleTypes[theType]
    if (not info) or (info.target ~= "server") then
        if isElement(thePlayer) then
            oct(thePlayer, gct("Collectible type '%s' does not exist.", theType))
            for theType2, info2 in pairs(collectibleTypes) do
                if info2.target == "server" then
                    outputChatBox("  - " .. theType2, thePlayer, 255, 255, 255)
                end
            end
        end
        return false, "INVALID_TYPE"
    end
    local countExisting = 0
    for pickup, info2 in pairs(spawnedServerCollectibles) do
        if info2.type == theType then
            countExisting = countExisting + 1
        end
    end
    if countExisting > 0 then
        if isElement(thePlayer) then
            oct(thePlayer, gct("There are currently %s %s collectibles spawned.", countExisting, (string.gsub(theType, "_", " "))))
        end
        return false, "ALREADY_SPAWNED"
    end
    for i=1, #info.spawnpoints do
        local sp = info.spawnpoints[i]
        if sp then
            collectibleTypes[theType].spawnpoints[i].collected_by = false
        end
    end
    local countCreated = 0
    for i=1, #info.spawnpoints do
        local spawnpoint = info.spawnpoints[i]
        if spawnpoint and createOnePickup(theType, spawnpoint.spID, spawnpoint) then
            countCreated = countCreated + 1
        end
    end
    if isElement(thePlayer) then
        oct(thePlayer, gct("You have spawned %s %s collectibles on the server.", countCreated, (string.gsub(theType, "_", " "))))
    end
    triggerEvent("collectibles:onSpawnedServer", root, (isElement(thePlayer) and thePlayer or "SYSTEM"), theType, countCreated)
    return true
end

--- **(Exported)**
function destroyCollectibles(theType, thePlayer)
    assert(type(theType) == "string", "Bad argument @ destroyCollectibles [expected string at argument 1, got " .. type(theType) .. "]")
    local info = collectibleTypes[theType]
    if (not info) or (info.target ~= "server") then
        if isElement(thePlayer) then
            oct(thePlayer, gct("Collectible type '%s' does not exist.", theType))
            for theType2, info2 in pairs(collectibleTypes) do
                if info2.target == "server" then
                    outputChatBox("  - " .. theType2, thePlayer, 255, 255, 255)
                end
            end
        end
        return false, "INVALID_TYPE"
    end
    local total = info.total
    for i=1, total do
        local sp = info.spawnpoints[i]
        if sp then
            collectibleTypes[theType].spawnpoints[i].collected_by = false
        end
    end
    local pickupsLeft = {}
    for pickup, info2 in pairs(spawnedServerCollectibles) do
        if info2.type == theType then
            pickupsLeft[#pickupsLeft+1] = pickup
        end
    end
    if #pickupsLeft == 0 then
        if isElement(thePlayer) then
            oct(thePlayer, gct("There are currently %s %s collectibles spawned.", 0, (string.gsub(theType, "_", " "))))
        end
        return false, "NOT_SPAWNED"
    end
    for i=1, #pickupsLeft do
        local pickup = pickupsLeft[i]
        destroyElement(pickup)
        spawnedServerCollectibles[pickup] = nil
    end
    if isElement(thePlayer) then
        oct(thePlayer, gct("You have destroyed the existing %s %s collectibles.", countLeft, (string.gsub(theType, "_", " "))))
    end
    triggerEvent("collectibles:onDestroyedServer", root, (isElement(thePlayer) and thePlayer or "SYSTEM"), theType, countLeft, total)
    return true
end

local function isCollectedClient(thePlayer, account, theType, respawn_after, spID)
    local dataName = getAccountDataNames().CLIENT_COUNTS
    local data = getAccountData(account, dataName)
    if not data then
        return false
    end
    data = fromJSON(data) or {}
    if not data[theType] then
        return false
    end
    local collectedAt = tonumber(data[theType][tostring(spID)])
    if not collectedAt then
        return false
    end
    local now = getRealTime().timestamp
    if (respawn_after) and ((now - collectedAt) > respawn_after) then
        data[theType][tostring(spID)] = nil
        setAccountData(account, dataName, toJSON(data))
        return false
    end
    return true
end

local function sendCollectibles(player, account)
    local collectiblesToSend = {}
    for theType, info in pairs(collectibleTypes) do
        if info.target == "client" then
            for i=1, #info.spawnpoints do
                local spawnpoint = info.spawnpoints[i]
                if spawnpoint then
                    info.spawnpoints[i].wasCollected = isCollectedClient(player, account, theType, info.respawn_after, spawnpoint.spID)
                end
            end
            collectiblesToSend[theType] = {
                target = info.target,
                name = info.name,
                toggled = (info.auto_load or false),
                toggle_keybind = info.toggle_keybind,
                toggle_command = info.toggle_command,
                collect_one = info.collect_one,
                collect_last = info.collect_last,
                total = info.total,
                spawnpoints = info.spawnpoints,
            }
        end
    end
    triggerClientEvent(player, "collectibles:receive", player,
        collectiblesToSend,
        CONSTANTS
    )
end

local function resendClientCollectibles()
    local playersTable = getElementsByType("player")
    for i=1, #playersTable do
        local player = playersTable[i]
        if player then
            local account = getPlayerAccount(player)
            if (account and not isGuestAccount(account)) then
                sendCollectibles(player, account)
            end
        end
    end
end

--- **(Exported)**
function removeSpawnpoint(theType, spID)
    assert(type(theType) == "string", "Bad argument @ removeSpawnpoint [expected string at argument 1, got " .. type(theType) .. "]")
    assert(type(spID) == "number", "Bad argument @ removeSpawnpoint [expected number at argument 2, got " .. type(spID) .. "]")
    local info = collectibleTypes[theType]
    if (not info) then
        return false, "Collectible type '%s' does not exist."
    end
    local spawnpoint, theIndex
    for i=1, #info.spawnpoints do
        local sp = info.spawnpoints[i]
        if sp and sp.spID == spID then
            spawnpoint = sp
            theIndex = i
            break
        end
    end
    if (not spawnpoint) then
        return false, "admin_invalid_spawnpoint_index"
    end

    local config = xmlLoadFile(CONSTANTS.COLLECTIBLES_FILE)
    if not config then
        return false, "Failed to load file "..CONSTANTS.COLLECTIBLES_FILE.."."
    end
    local children = xmlNodeGetChildren(config)
    if not children then
        xmlUnloadFile(config)
        return false, "Failed to get children of "..CONSTANTS.COLLECTIBLES_FILE.."."
    end

    local found = false
    for i=1, #children do
        local child = children[i]
        if child and xmlNodeGetName(child) == "spawnpoints" then
            local spawnpoints2 = xmlNodeGetChildren(child)
            if not spawnpoints2 then
                xmlUnloadFile(config)
                return false, "Failed to get children of 'spawnpoints' in "..CONSTANTS.COLLECTIBLES_FILE.."."
            end
            for i2=1, #spawnpoints2 do
                local spawnpoint2 = spawnpoints2[i2]
                if spawnpoint2 and xmlNodeGetName(spawnpoint2) == "spawnpoint" then
                    local theType2 = xmlNodeGetAttribute(spawnpoint2, "type")
                    if theType == theType2 then
                        local id = tonumber(xmlNodeGetAttribute(spawnpoint2, "id"))
                        if id and id == spID then
                            xmlDestroyNode(spawnpoint2)
                            found = true
                            break
                        end
                    end
                end
            end
            if found then
                break
            end
        end
    end
    if not found then
        xmlUnloadFile(config)
        return false, "Failed to find spawnpoint in "..CONSTANTS.COLLECTIBLES_FILE.."."
    end

    if not xmlSaveFile(config) then
        xmlUnloadFile(config)
        return false, "Failed to save file "..CONSTANTS.COLLECTIBLES_FILE.."."
    end
    xmlUnloadFile(config)

    table.remove(collectibleTypes[theType].spawnpoints, theIndex)

    collectibleTypes[theType].total = collectibleTypes[theType].total - 1
    for pickup, info2 in pairs(spawnedServerCollectibles) do
        if info2.type == theType and info2.spID == spID then
            destroyElement(pickup)
            spawnedServerCollectibles[pickup] = nil
        end
    end

    if info.target == "client" then
        -- reset all accounts' collected counts of this type
        local dataName = getAccountDataNames().CLIENT_COUNTS
        local accounts = getAccounts()
        local collectedCounts = {}
        for i=1, #accounts do
            local account = accounts[i]
            if account then
                local data = getAccountData(account, dataName)
                if not data then
                    data = {}
                else
                    data = fromJSON(data) or {}
                end
                data[theType] = nil
                setAccountData(account, dataName, toJSON(data))
            end
        end

        resendClientCollectibles()
    end

    return true
end

--- **(Exported)**
function createNewSpawnpoint(theType, model, x,y,z, interior, dimension)
    assert(type(theType) == "string", "Bad argument @ createNewSpawnpoint [expected string at argument 1, got " .. type(theType) .. "]")
    assert(type(model) == "number", "Bad argument @ createNewSpawnpoint [expected number at argument 2, got " .. type(model) .. "]")
    assert(type(x) == "number", "Bad argument @ createNewSpawnpoint [expected number at argument 3, got " .. type(x) .. "]")
    assert(type(y) == "number", "Bad argument @ createNewSpawnpoint [expected number at argument 4, got " .. type(y) .. "]")
    assert(type(z) == "number", "Bad argument @ createNewSpawnpoint [expected number at argument 5, got " .. type(z) .. "]")
    assert(type(interior) == "number", "Bad argument @ createNewSpawnpoint [expected number at argument 6, got " .. type(interior) .. "]")
    assert(type(dimension) == "number", "Bad argument @ createNewSpawnpoint [expected number at argument 7, got " .. type(dimension) .. "]")
    local info = collectibleTypes[theType]
    if (not info) then
        return false, "Collectible type '%s' does not exist."
    end

    local config = xmlLoadFile(CONSTANTS.COLLECTIBLES_FILE)
    if not config then
        return false, "Failed to load file "..CONSTANTS.COLLECTIBLES_FILE.."."
    end
    local children = xmlNodeGetChildren(config)
    if not children then
        xmlUnloadFile(config)
        return false, "Failed to get children of "..CONSTANTS.COLLECTIBLES_FILE.."."
    end

    local lastSpID = 0
    for i=1, #info.spawnpoints do
        local spawnpoint = info.spawnpoints[i]
        if spawnpoint and spawnpoint.spID > lastSpID then
            lastSpID = spawnpoint.spID
        end
    end
    lastSpID = lastSpID + 1

    for i=1, #children do
        local child = children[i]
        if child and xmlNodeGetName(child) == "spawnpoints" then
            local newSpawnpoint = xmlCreateChild(child, "spawnpoint")
            xmlNodeSetAttribute(newSpawnpoint, "type", theType)
            xmlNodeSetAttribute(newSpawnpoint, "id", lastSpID)
            xmlNodeSetAttribute(newSpawnpoint, "model", model)
            xmlNodeSetAttribute(newSpawnpoint, "x", x)
            xmlNodeSetAttribute(newSpawnpoint, "y", y)
            xmlNodeSetAttribute(newSpawnpoint, "z", z)
            xmlNodeSetAttribute(newSpawnpoint, "interior", interior)
            xmlNodeSetAttribute(newSpawnpoint, "dimension", dimension)
            break
        end
    end
    if not xmlSaveFile(config) then
        xmlUnloadFile(config)
        return false, "Failed to save file "..CONSTANTS.COLLECTIBLES_FILE.."."
    end
    xmlUnloadFile(config)

    local newIndex = #collectibleTypes[theType].spawnpoints + 1
    collectibleTypes[theType].spawnpoints[newIndex] = {
        spID = lastSpID,
        model = model,
        x = x,
        y = y,
        z = z,
        interior = interior,
        dimension = dimension,
    }
    collectibleTypes[theType].total = #info.spawnpoints

    if info.target == "client" then
        resendClientCollectibles()
    else
        local pickupsSpawned = {}
        for pickup, info2 in pairs(spawnedServerCollectibles) do
            if info2.type == theType then
                pickupsSpawned[#pickupsSpawned+1] = pickup
            end
        end
        if (info.auto_load == true or #pickupsSpawned > 0) then
            createOnePickup(theType, lastSpID, collectibleTypes[theType].spawnpoints[newIndex])
        end
    end
    return lastSpID
end

local function createServerCollectibles()
    for theType, info in pairs(collectibleTypes) do
        if info.target == "server" then

            for i=1, #info.spawnpoints do
                local sp = info.spawnpoints[i]
                if sp then
                    collectibleTypes[theType].spawnpoints[i].collected_by = false
                end
            end

            if (info.auto_load == true) then
                -- Auto create on startup
                for i=1, #info.spawnpoints do
                    local spawnpoint = info.spawnpoints[i]
                    if spawnpoint then
                        createOnePickup(theType, spawnpoint.spID, spawnpoint)
                    end
                end
            end
        end
    end
end

local function countCollectedServer(accountID, theType)
    local count = 0
    for i=1, #collectibleTypes[theType].spawnpoints do
        local sp = collectibleTypes[theType].spawnpoints[i]
        if sp and sp.collected_by == accountID then
            count = count + 1
        end
    end
    return count
end

local function saveCollectedClient(account, theType, spID)
    local dataName = getAccountDataNames().CLIENT_COUNTS
    local data = getAccountData(account, dataName)
    if not data then
        data = {}
    else
        data = fromJSON(data) or {}
    end
    if not data[theType] then
        data[theType] = {}
    end
    data[theType][tostring(spID)] = getRealTime().timestamp
    setAccountData(account, dataName, toJSON(data))
end

local function despawnCollectibles(player)
    triggerClientEvent(player, "collectibles:despawn", player)
end

local function countCollectedClient(thePlayer, account, theType, respawn_after)
    local dataName = getAccountDataNames().CLIENT_COUNTS
    local data = getAccountData(account, dataName)
    if not data then
        return 0
    end
    data = fromJSON(data) or {}
    if not data[theType] then
        return 0
    end
    local now = getRealTime().timestamp
    local count = 0
    local forceRespawn = false
    for spID, collectedAt in pairs(data[theType]) do
        collectedAt = tonumber(collectedAt)
        if collectedAt then
            if (respawn_after) and ((now - collectedAt) > respawn_after) then
                data[theType][tostring(spID)] = nil
                setAccountData(account, dataName, toJSON(data))

                if not forceRespawn and isElement(thePlayer) then
                    forceRespawn = true
                end
            else
                count = count + 1
            end
        end
    end
    if forceRespawn then
        sendCollectibles(thePlayer, account)
    end
    return count
end

--- **(Exported)**
function getCollectedCounts(account)
    local accountID = getAccountID(account)
    assert(type(accountID)=="number", "Bad argument @ getCollectedCounts [valid account expected, got " .. tostring(account) .. "]")
    local serverCounts = {}
    local clientCounts = {}
    for theType, info in pairs(collectibleTypes) do
        if info.target == "server" then
            local spawnedPickups = {}
            for pickup, data in pairs(spawnedServerCollectibles) do
                if data.type == theType then
                    spawnedPickups[data.spID] = pickup
                end
            end
            local count = countCollectedServer(accountID, theType)
            serverCounts[theType] = {count = count, total = info.total, spawnpoints = info.spawnpoints, spawnedPickups = spawnedPickups}
        elseif info.target == "client" then
            local count = countCollectedClient(false, account, theType, info.respawn_after)
            clientCounts[theType] = {count = count, total = info.total, spawnpoints = info.spawnpoints}
        end
    end
    return {server = serverCounts, client = clientCounts}
end

local function respawnAllClientCollectibles()
    local playersTable = getElementsByType("player")
    for i=1, #playersTable do
        local thePlayer = playersTable[i]
        if thePlayer then
            local account = getPlayerAccount(thePlayer)
            if (account) and (not isGuestAccount(account)) then
                for theType, info in pairs(collectibleTypes) do
                    if info.target == "client" then
                        local respawn_after = info.respawn_after
                        countCollectedClient(thePlayer, account, theType, respawn_after)
                    end
                end
            end
        end
    end
end

--- **(Exported)**
function resetClientCollectibles(targetAccount, theType, thePlayer)
    local targetAccountID = getAccountID(targetAccount)
    assert(type(targetAccountID)=="number", "Bad argument @ getCollectedCounts [valid account expected, got " .. tostring(targetAccount) .. "]")
    assert(type(theType) == "string", "Bad argument @ resetClientCollectibles [string expected, got " .. type(theType) .. "]")
    if theType ~= "all" and ((not collectibleTypes[theType]) or (collectibleTypes[theType].target ~= "client")) then
        if isElement(thePlayer) then
            oct(thePlayer, gct("Collectible type '%s' does not exist.", theType))
            for theType2, info2 in pairs(collectibleTypes) do
                if info2.target == "client" then
                    outputChatBox("  - " .. theType2, thePlayer, 255, 255, 255)
                end
            end
        end
        return false, "Collectible type '%s' does not exist."
    end
    local dataName = getAccountDataNames().CLIENT_COUNTS
    local data = getAccountData(targetAccount, dataName)
    if not data then
        data = {}
    else
        data = fromJSON(data) or {}
    end
    if theType == "all" then
        for theType2, info in pairs(collectibleTypes) do
            if info.target == "client" then
                data[theType2] = {}
            end
        end
    else
        data[theType] = {}
    end
    setAccountData(targetAccount, dataName, toJSON(data))
    local targetPlayer = nil
    local playersTable = getElementsByType("player")
    for i=1, #playersTable do
        local player = playersTable[i]
        if player then
            local account = getPlayerAccount(player)
            if (account) and (not isGuestAccount(account)) then
                if getAccountID(account) == targetAccountID then
                    targetPlayer = player
                    break
                end
            end
        end
    end
    if targetPlayer then
        sendCollectibles(targetPlayer, targetAccount)
        oct(targetPlayer, gct("admin_reset_success_player", (string.gsub(theType, "_", " "))))
    end
    if isElement(thePlayer) then
        local targetAccountName = getAccountName(targetAccount)
        oct(thePlayer, gct("You have reset and respawned %s client collectibles for %s (ID: %s).", (string.gsub(theType, "_", " ")), targetAccountName, tostring(targetAccountID)))
    end
    return true
end

local function handlePickedUp(serversidePickup, collectibleInfo_)
    if not client then return end
    if (type(collectibleTypes)~="table") then
        return false, "Unexpected error: collectibleTypes is not a table"
    end
    local account = getPlayerAccount(client)
    if (not account) or (isGuestAccount(account)) then
        return false, "Guest account"
    end
    local accountName = getAccountName(account)
    local accountID = getAccountID(account)
    if serversidePickup and not (isElement(serversidePickup) and getElementType(serversidePickup) == "pickup") then
        return false, "serversidePickup is not a pickup element"
        --hacker?
    end
    if not collectibleInfo_ and not serversidePickup then
        return false, "Missing collectibleInfo_ and serversidePickup"
        --hacker?
    end
    if serversidePickup and not collectibleInfo_ then
        collectibleInfo_ = spawnedServerCollectibles[serversidePickup]
        if type(collectibleInfo_) ~= "table" then
            return false, "Missing spawnedServerCollectibles for pickup "..inspect(serversidePickup)
            --hacker?
        end
        collectibleInfo = collectibleInfo_
    else
        if type(collectibleInfo_) ~= "table" then
            return false, "Bad collectibleInfo"
            --hacker?
        end
        if type(collectibleInfo_.type) ~= "string" then
            return false, "Bad collectibleInfo.type"
            --hacker?
        end
        if type(collectibleInfo_.spID) ~= "number" then
            return false, "Bad collectibleInfo.spID"
            --hacker?
        end
        collectibleInfo = collectibleInfo_
    end

    local theType = collectibleInfo.type
    if not collectibleTypes[theType] then
        return false, "Unknown collectible type '"..theType.."'"
        --hacker?
    end
    local target = collectibleTypes[theType].target
    local spID = collectibleInfo.spID
    local respawn_after = collectibleTypes[theType].respawn_after
    if (target == "server") and not serversidePickup then
        return false, "Client tried to force pickup serverside collectible '"..theType.."' #"..spID
        --hacker?
    end
    local foundSpawnpoint = false
    for i=1, #collectibleTypes[theType].spawnpoints do
        local spawnpoint = collectibleTypes[theType].spawnpoints[i]
        if spawnpoint and (spawnpoint.spID == spID) then
            foundSpawnpoint = true
            break
        end
    end
    if not foundSpawnpoint then
        return false, "Type '"..theType.."' does not have spawnpoint ID "..spID
        --hacker?
    end
    if not canCollectPickup(client, account, theType) then
        triggerClientEvent(client, "collectibles:pickupDenied", client, theType, spID)
        return true
    end

    -- success, pick it up:
    local count
    if (target == "server") then
        count = countCollectedServer(accountID, theType) + 1
        for i=1, #collectibleTypes[theType].spawnpoints do
            local spawnpoint = collectibleTypes[theType].spawnpoints[i]
            if spawnpoint and (spawnpoint.spID == spID) then
                collectibleTypes[theType].spawnpoints[i].collected_by = accountID
                break
            end
        end
        destroyElement(serversidePickup)
        spawnedServerCollectibles[serversidePickup] = nil
    else
        count = countCollectedClient(client, account, theType, respawn_after) + 1
        saveCollectedClient(account, theType, spID)
        -- pickup will be destroyed on client
    end

    local total = collectibleTypes[theType].total

    local reward = collectibleTypes[theType].collect_one
    local rewardLast = collectibleTypes[theType].collect_last
    if count == total and rewardLast.reward_money then
        reward = rewardLast
    end
    local rewardMoney = reward.reward_money
    if rewardMoney then
        if givePlayerMoney(client, rewardMoney) then
            oct(client, gct("You have earned $%s for collecting this %s.", rewardMoney, (string.gsub(theType, "_", " "))))
        end
    end

    local visualFx = collectibleTypes[theType].collect_one
    local visualFxLast = collectibleTypes[theType].collect_last
    if count == total and visualFxLast.sound then
        visualFx = visualFxLast
    end
    
    triggerClientEvent(client, "collectibles:onCollectVisuals", client, theType, count, total, visualFx)

    -- Custom Event (for Developers)
    triggerEvent("collectibles:onCollected", client, account, accountID, accountName, collectibleTypes[theType].target, theType, count, total)
    return true
end

local function requestHandlePickedUp(...)
    local result, reason = handlePickedUp(...)
    if not result then
        outputDebugMsg("collectibles:handlePickedUp failed: " .. tostring(reason), "ERROR")
    end
end
addEventHandler("collectibles:handlePickedUp", resourceRoot, requestHandlePickedUp)

addEventHandler("onPickupHit", resourceRoot, function()
    cancelEvent()
end, true, "high+9")

addEventHandler("onPlayerLogin", root, function(_, newAccount)
    if isGuestAccount(newAccount) then
        despawnCollectibles(source)
        return
    end
    if type(clientsWaiting)=="table" then
        clientsWaiting[#clientsWaiting+1] = source
    else
        sendCollectibles(source, newAccount)
    end
end)

addEventHandler("onPlayerLogout", root, function(_, newAccount)
    if isGuestAccount(newAccount) then
        despawnCollectibles(source)
        return
    end
    if type(clientsWaiting)=="table" then
        clientsWaiting[#clientsWaiting+1] = source
    else
        sendCollectibles(source, newAccount)
    end
end)

addEventHandler("collectibles:requestCollectibles", resourceRoot, function()
    if not client then return end
    local account = getPlayerAccount(client)
    if (not account) or (isGuestAccount(account)) then return end
    sendCollectibles(client, account)
end, false)

addEventHandler("onResourceStart", resourceRoot, function()

    local success1, reason1 = parseCustomSettings()
    if not success1 then
        outputInfoMessage(reason1)
        return cancelEvent()
    end

    local success, reason = loadConfiguration()
    if not success then
        outputInfoMessage(reason)
        outputInfoMessage("Restore a configuration file from the 'backups' folder if needed.")
        return cancelEvent()
    end

    outputInfoMessage("Successfully loaded configuration.")
    
    createServerCollectibles()

    for i=1, #clientsWaiting do
        local player = clientsWaiting[i]
        if player then
            local account = getPlayerAccount(player)
            if (account) and (not isGuestAccount(account)) then
                sendCollectibles(player, account)
            end
        end
    end

    clientsWaiting = nil -- clear memory

    setTimer(respawnAllClientCollectibles, 30000, 0)
end, false)
