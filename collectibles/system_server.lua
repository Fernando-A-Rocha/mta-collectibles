--[[
    Author: https://github.com/Fernando-A-Rocha

    Collectibles - System (Server)

    Administrative commmands:
        - /resetcollectibles

    /!\ Unless you know what you are doing, do not edit this file. /!\
]]

-- Internal Events
addEvent("collectibles:handlePickedUp", true)

-- Custom Events (for Developers)
addEvent("collectibles:onCollected", true)

local clientsWaiting = {} -- initial startup
local collectibleTypes = {}
local texts = {}
local spawnedCollectibles = {}
local collectedCount = {}

local function outputInfoMessage(msg)
    msg = "[Collectibles] " .. msg
    outputServerLog(msg)
end

local function outputCustomText(player, name, ...)
    local info = texts[name]
    if not info then
        return
    end
    local text = info.text
    local r,g,b = info.r, info.g, info.b
    local formatWith = {...}
    if #formatWith > 0 then
        text = string.format(text, unpack(formatWith))
    end
    outputChatBox(text, player, r, g, b, true)
end

-- This may be customized
local function canManageCollectibles(player)
    local account = getPlayerAccount(player)
    if (not account) or isGuestAccount(account) then
        return false
    end
    local accountName = getAccountName(account)
    return isObjectInACLGroup("user." .. accountName, aclGetGroup("Admin"))
end

local function parseOneNode(rootChildren, targetNodeName)
    for i=1, #rootChildren do
        local node = rootChildren[i]
        if node then
            local nodeName = xmlNodeGetName(node)
            if targetNodeName == nodeName then
                if nodeName == "types" then
                    local children = xmlNodeGetChildren(node)
                    if not children then
                        return false, "Failed to get children of 'types' node."
                    end
                    for i=1, #children do
                        local child = children[i]
                        if child then
                            local childName = xmlNodeGetName(child)
                            if childName ~= "type" then
                                return false, "Invalid child node '" .. childName .. "' of 'types' node."
                            end
                            local name = xmlNodeGetAttribute(child, "name")
                            if not name then
                                return false, "Missing attribute 'name' of 'type' node."
                            end
                            if collectibleTypes[name] then
                                return false, "Duplicate collectible type '" .. name .. "'."
                            end
                            local target = xmlNodeGetAttribute(child, "target")
                            if (not target) then
                                return false, "Missing attribute 'target' of 'type' node."
                            end
                            if not (target == "client" or target == "server") then
                                return false, "Invalid attribute 'target' of 'type' node, expected client/server."
                            end
                            local toggle_keybind = xmlNodeGetAttribute(child, "toggle_keybind") or false
                            local toggle_command = xmlNodeGetAttribute(child, "toggle_command") or false
                            if ((toggle_command or toggle_keybind) and target=="server") then
                                return false, "'toggle_keybind' or 'toggle_command' are only for client-side collectibles."
                            end
                            if toggle_keybind then
                                toggle_keybind = string.lower(toggle_keybind)
                            end
                            local auto_load = xmlNodeGetAttribute(child, "auto_load") or false
                            if auto_load and auto_load ~= "true" and auto_load ~= "false" then
                                return false, "Invalid attribute 'auto_load' of 'type' node, expected true/false."
                            end
                            if auto_load == "true" then
                                auto_load = true
                            else
                                auto_load = false
                            end
                            local spawn_command = xmlNodeGetAttribute(child, "spawn_command") or false
                            local destroy_command = xmlNodeGetAttribute(child, "destroy_command") or false
                            if (spawn_command or destroy_command) then
                                if (target=="client") then
                                    return false, "'spawn_command' or 'destroy_command' are only for server-side collectibles."
                                end
                                if (not spawn_command) or (not destroy_command) then
                                    return false, "Both 'spawn_command' and 'destroy_command' must be set for server-side collectibles."
                                end
                            end
                            local respawn_after = xmlNodeGetAttribute(child, "respawn_after") or false
                            local respawn_after_unit = xmlNodeGetAttribute(child, "respawn_after_unit") or false
                            if (target=="client") then
                                if not respawn_after then
                                    return false, "Missing attribute 'respawn_after' of 'type' node - must be set for client-side collectibles."
                                end
                                respawn_after = tonumber(respawn_after)
                                if (not respawn_after) or (respawn_after < 0) then
                                    return false, "Invalid attribute 'respawn_after' of 'type' node - must be a number greater than 0."
                                end
                                if not (respawn_after_unit == "seconds" or respawn_after_unit == "minutes" or respawn_after_unit == "hours") then
                                    return false, "Invalid attribute 'respawn_after_unit' of 'type' node - must be seconds/minutes/hours."
                                end
                                -- convert to seconds
                                if respawn_after_unit == "minutes" then
                                    respawn_after = respawn_after * 60
                                elseif respawn_after_unit == "hours" then
                                    respawn_after = respawn_after * 60 * 60
                                end
                            end
                            collectibleTypes[name] = {
                                target = target,
                                toggle_keybind = toggle_keybind,
                                toggle_command = toggle_command,
                                spawn_command = spawn_command,
                                destroy_command = destroy_command,
                                respawn_after = respawn_after,
                                auto_load = auto_load,
                            }
                        end
                    end
                elseif nodeName == "actions" then
                    local children = xmlNodeGetChildren(node)
                    if not children then
                        return false, "Failed to get children of 'actions' node."
                    end
                    for i=1, #children do
                        local child = children[i]
                        if child then
                            local childName = xmlNodeGetName(child)
                            if childName ~= "action" then
                                return false, "Invalid child node '" .. childName .. "' of 'actions' node."
                            end
                            local type = xmlNodeGetAttribute(child, "type")
                            if not type then
                                return false, "Missing attribute 'type' of 'action' node."
                            end
                            local on = xmlNodeGetAttribute(child, "on")
                            if not on then
                                return false, "Missing attribute 'on' of 'action' node."
                            end
                            if not (on == "collect_one" or on == "collect_all") then
                                return false, "Invalid attribute 'on' of 'action' node."
                            end
                            local sound = xmlNodeGetAttribute(child, "sound") or false
                            local sound_volume = xmlNodeGetAttribute(child, "sound_volume")
                            if sound then
                                if not fileExists(sound) then
                                    return false, "Invalid attribute 'sound' of 'action' node - file does not exist."
                                end
                                sound_volume = tonumber(sound_volume)
                                if (not sound_volume) or (sound_volume < 0) then
                                    return false, "Invalid attribute 'sound_volume' of 'action' node - must be a number greater than 0."
                                end
                            end
                            local reward_money = xmlNodeGetAttribute(child, "reward_money") or false
                            if reward_money then
                                reward_money = tonumber(reward_money)
                                if (not reward_money) or (reward_money < 0) then
                                    return false, "Invalid attribute 'reward_money' of 'action' node - must be a number greater than 0."
                                end
                            end
                            local collectibleType = collectibleTypes[type]
                            if not collectibleType then
                                return false, "Invalid type '" .. type .. "' of 'action' node."
                            end
                            collectibleTypes[type][on] = {
                                name = on,
                                sound = sound,
                                sound_volume = sound_volume,
                                reward_money = reward_money,
                            }
                        end
                    end
                elseif nodeName == "spawnpoints" then
                    local children = xmlNodeGetChildren(node)
                    if not children then
                        return false, "Failed to get children of 'spawnpoints' node."
                    end
                    for i=1, #children do
                        local child = children[i]
                        if child then
                            local childName = xmlNodeGetName(child)
                            if childName ~= "spawnpoint" then
                                return false, "Invalid child node '" .. childName .. "' of 'spawnpoints' node."
                            end
                            local type = xmlNodeGetAttribute(child, "type")
                            if not type then
                                return false, "Missing attribute 'type' of 'spawnpoint' node."
                            end
                            local x = xmlNodeGetAttribute(child, "x")
                            if not x then
                                return false, "Missing attribute 'x' of 'spawnpoint' node."
                            end
                            x = tonumber(x)
                            if (not x) then
                                return false, "Invalid attribute 'x' of 'spawnpoint' node - must be a number."
                            end
                            local y = xmlNodeGetAttribute(child, "y")
                            if not y then
                                return false, "Missing attribute 'y' of 'spawnpoint' node."
                            end
                            y = tonumber(y)
                            if (not y) then
                                return false, "Invalid attribute 'y' of 'spawnpoint' node - must be a number."
                            end
                            local z = xmlNodeGetAttribute(child, "z")
                            if not z then
                                return false, "Missing attribute 'z' of 'spawnpoint' node."
                            end
                            z = tonumber(z)
                            if (not z) then
                                return false, "Invalid attribute 'z' of 'spawnpoint' node - must be a number."
                            end
                            local model = xmlNodeGetAttribute(child, "model")
                            if not model then
                                return false, "Missing attribute 'model' of 'spawnpoint' node."
                            end
                            model = tonumber(model)
                            if (not model) or (model < 0) then
                                return false, "Invalid attribute 'model' of 'spawnpoint' node - must be a number greater than 0."
                            end
                            local testPickup = createPickup(x, y, z, 3, model)
                            if not testPickup then
                                destroyElement(testPickup)
                                return false, "Invalid attribute 'model' of 'spawnpoint' node - invalid object model ID."
                            end
                            destroyElement(testPickup)
                            for theType, info in pairs(collectibleTypes) do
                                if info.spawnpoints then
                                    for i=1, #info.spawnpoints do
                                        local spawnpoint = info.spawnpoints[i]
                                        if spawnpoint.x == x and spawnpoint.y == y and spawnpoint.z == z then
                                            return false, "Duplicate spawnpoint at position " .. x .. ", " .. y .. ", " .. z .. "."
                                        end
                                    end
                                end
                            end
                            collectibleTypes[type].spawnpoints = collectibleTypes[type].spawnpoints or {}
                            local index = #collectibleTypes[type].spawnpoints + 1
                            collectibleTypes[type].spawnpoints[index] = {
                                index = index,
                                x = x,
                                y = y,
                                z = z,
                                model = model,
                            }
                        end
                    end
                elseif nodeName == "texts" then
                    local children = xmlNodeGetChildren(node)
                    if not children then
                        return false, "Failed to get children of 'texts' node."
                    end
                    for i=1, #children do
                        local child = children[i]
                        if child then
                            local childName = xmlNodeGetName(child)
                            if childName ~= "text" then
                                return false, "Invalid child node '" .. childName .. "' of 'texts' node."
                            end
                            local name = xmlNodeGetAttribute(child, "name")
                            if not name then
                                return false, "Missing attribute 'name' of 'text' node."
                            end
                            if texts[name] then
                                return false, "Duplicate attribute 'name' of 'text' node."
                            end
                            local value = xmlNodeGetValue(child)
                            if not value then
                                return false, "Missing value of 'text' node."
                            end
                            if value == "" then
                                return false, "Invalid value of 'text' node - must not be empty."
                            end
                            local color = xmlNodeGetAttribute(child, "color")
                            if not color then
                                return false, "Missing attribute 'color' of 'text' node."
                            end
                            color = string.gsub(color, " ", "")
                            color = split(color, ",")
                            if #color ~= 3 then
                                return false, "Invalid attribute 'color' of 'text' node - must be a string in the format 'r,g,b' e.g. 255,255,0."
                            end
                            local colorTable = {}
                            for i=1, #color do
                                local value = tonumber(color[i])
                                if (not value) or (value < 0) or (value > 255) then
                                    return false, "Invalid attribute 'color' of 'text' node - must be a string in the format 'r,g,b' e.g. 255,255,0."
                                end
                                colorTable[i] = value
                            end
                            texts[name] = {
                                text = value,
                                r = colorTable[1],
                                g = colorTable[2],
                                b = colorTable[3],
                            }
                        end
                    end
                end
            end
        end
    end
    return true
end

local function loadConfiguration()

    -- if not fileExists("config.xml.backup") then
    --     local backup = fileCreate("config.xml.backup")
    --     if not backup then
    --         return false, "Failed to create backup file 'config.xml.backup' - check permissions."
    --     end
    --     local config = fileOpen("config.xml")
    --     if not config then
    --         return false, "Failed to open file 'config.xml' - check permissions."
    --     end
    --     local content = fileRead(config, fileGetSize(config))
    --     fileWrite(backup, content)
    --     fileClose(config)
    --     fileClose(backup)
    -- end

    local config = xmlLoadFile("config.xml")
    if not config then
        return false, "Failed to load file 'config.xml'."
    end

    local children = xmlNodeGetChildren(config)
    if not children then
        return false, "Failed to get children of 'config.xml'."
    end

    local success, reason, theType = parseOneNode(children, "types")
    if not success then
        return false, "Failed to parse <types>: " .. reason
    end
    success, reason = parseOneNode(children, "actions")
    if not success then
        return false, "Failed to parse <actions>: " .. reason
    end
    for theType, info in pairs(collectibleTypes) do
        if not info.collect_one then
            return false, "Missing action 'collect_one' for type '" .. theType .. "'."
        end
        if not info.collect_all then
            return false, "Missing action 'collect_all' for type '" .. theType .. "'."
        end
    end
    success, reason = parseOneNode(children, "spawnpoints")
    if not success then
        return false, "Failed to parse <spawnpoints>: " .. reason
    end
    for theType, info in pairs(collectibleTypes) do
        if not info.spawnpoints then
            return false, "Missing spawnpoints for type '" .. theType .. "'."
        end
        collectibleTypes[theType].total = #info.spawnpoints
    end
    success, reason = parseOneNode(children, "texts")
    if not success then
        return false, "Failed to parse <texts>: " .. reason
    end
    local EXPECTED_TEXTS = {
        "command_syntax",
        "cant_toggle", "toggle_on", "toggle_off", "respawned", "collect_one", "collect_all", "already_collected",
        "admin_no_permission", "admin_already_spawned", "admin_spawned", "admin_destroyed", "admin_invalid_collectible_type", "admin_invalid_account_name", "admin_reset_success"
    }
    for i=1, #EXPECTED_TEXTS do
        local name = EXPECTED_TEXTS[i]
        if not texts[name] then
            return false, "Missing text '" .. name .. "'."
        end
    end

    xmlUnloadFile(config)
    return true
end

local function spawnCollectibles(theType, info, thePlayer)
    if not canManageCollectibles(thePlayer) then
        outputCustomText(thePlayer, "admin_no_permission")
        return
    end
    local countExisting = 0
    for pickup, info in pairs(spawnedCollectibles) do
        if info.type == theType then
            countExisting = countExisting + 1
        end
    end
    if countExisting > 0 then
        outputCustomText(thePlayer, "admin_already_spawned", countExisting, theType)
        return
    end
    for i=1, #info.spawnpoints do
        collectibleTypes[theType].spawnpoints[i].collected_by = false
    end
    local countCreated = 0
    for i=1, #info.spawnpoints do
        local spawnpoint = info.spawnpoints[i]
        local pickup = createPickup(spawnpoint.x, spawnpoint.y, spawnpoint.z, 3, spawnpoint.model)
        if not pickup then
            outputInfoMessage("Failed to create pickup for type '" .. theType .. "' at spawnpoint " .. (i) .. ".")
        else
            spawnedCollectibles[pickup] = {
                type = theType,
                index = spawnpoint.index,
            }
            countCreated = countCreated + 1
        end
    end
    outputCustomText(thePlayer, "admin_spawned", countCreated, theType)
end

local function destroyCollectibles(theType, info, thePlayer)
    if not canManageCollectibles(thePlayer) then
        outputCustomText(thePlayer, "admin_no_permission")
        return
    end
    for i=1, #info.spawnpoints do
        collectibleTypes[theType].spawnpoints[i].collected_by = false
    end
    local countLeft = 0
    for pickup, info2 in pairs(spawnedCollectibles) do
        if info2.type == theType then
            destroyElement(pickup)
            spawnedCollectibles[pickup] = nil
            countLeft = countLeft + 1
        end
    end
    outputCustomText(thePlayer, "admin_destroyed", countLeft, theType)
end

local function createServerCollectibles()
    for theType, info in pairs(collectibleTypes) do
        if info.target == "server" then

            for i=1, #info.spawnpoints do
                collectibleTypes[theType].spawnpoints[i].collected_by = false
            end

            if (info.auto_load == true) then
                -- Auto create on startup
                for i=1, #info.spawnpoints do
                    local spawnpoint = info.spawnpoints[i]
                    local pickup = createPickup(spawnpoint.x, spawnpoint.y, spawnpoint.z, 3, spawnpoint.model)
                    if not pickup then
                        outputInfoMessage("Failed to create pickup for type '" .. theType .. "' at spawnpoint " .. i .. ".")
                    else
                        spawnedCollectibles[pickup] = {
                            type = theType,
                            index = spawnpoint.index,
                        }
                    end
                end
            end
            if (info.spawn_command and info.destroy_command) then
                outputInfoMessage("'" .. theType .. "' collectibles can now be spawned using /"..(info.spawn_command))

                addCommandHandler(info.spawn_command, function(thePlayer, cmd)
                    spawnCollectibles(theType, info, thePlayer)
                end, false, false)

                addCommandHandler(info.destroy_command, function(thePlayer, cmd)
                    destroyCollectibles(theType, info, thePlayer)
                end, false, false)
            end
        end
    end
end

local function countCollectedServer(accountName, theType)
    local count = 0
    for i=1, #collectibleTypes[theType].spawnpoints do
        if collectibleTypes[theType].spawnpoints[i].collected_by == accountName then
            count = count + 1
        end
    end
    return count
end

local function spawnClientCollectible(theType, index, thePlayer)
    local spawnpoint = collectibleTypes[theType].spawnpoints[index]
    triggerClientEvent(thePlayer, "collectibles:spawn", thePlayer, theType, index, spawnpoint)
end

local function saveCollectedClient(account, accountName, theType, index)
    local data = getAccountData(account, "collectibiles.client")
    if not data then
        data = {}
    else
        data = fromJSON(data) or {}
    end
    if not data[theType] then
        data[theType] = {}
    end
    data[theType][tostring(index)] = getRealTime().timestamp
    setAccountData(account, "collectibiles.client", toJSON(data))
end

local function isCollectedClient(thePlayer, account, theType, respawn_after, index)
    local data = getAccountData(account, "collectibiles.client")
    if not data then
        return false
    end
    data = fromJSON(data) or {}
    if not data[theType] then
        return false
    end
    local collectedAt = tonumber(data[theType][tostring(index)])
    if not collectedAt then
        return false
    end
    local now = getRealTime().timestamp
    if (now - collectedAt) > respawn_after then
        data[theType][tostring(index)] = nil
        setAccountData(account, "collectibiles.client", toJSON(data))
        spawnClientCollectible(theType, tonumber(index), thePlayer)
        return false
    end
    return true
end

local function sendCollectibles(player, thisType)
    local account = getPlayerAccount(player)
    if (not account) or (isGuestAccount(account)) then
        return
    end
    local collectibleTypesClient = {}
    for theType, info in pairs(collectibleTypes) do
        if info.target == "client" and (not thisType or thisType == theType) then
            local spawnpoints = {}
            for i=1, #info.spawnpoints do
                local spawnpoint = info.spawnpoints[i]
                local alreadyCollected = false
                if accountName ~= true then
                    alreadyCollected = isCollectedClient(player, account, theType, info.respawn_after, spawnpoint.index)
                end
                if not alreadyCollected then
                    -- no longer ipairs list because some may already be collected (won't spawn)
                    spawnpoints[spawnpoint.index] = {
                        index = spawnpoint.index,
                        x = spawnpoint.x,
                        y = spawnpoint.y,
                        z = spawnpoint.z,
                        model = spawnpoint.model,
                    }
                end
            end
            local toggled = (info.auto_load or false)
            collectibleTypesClient[theType] = {
                name = info.name,
                toggled = toggled,
                toggle_keybind = info.toggle_keybind,
                toggle_command = info.toggle_command,
                collect_one = info.collect_one,
                collect_all = info.collect_all,
                total = info.total,
                spawnpoints = spawnpoints,
            }
        end
    end
    triggerClientEvent(player, "collectibles:receive", player,
        collectibleTypesClient,
        texts
    )
end

local function countCollectedClient(thePlayer, account, theType, respawn_after)
    local data = getAccountData(account, "collectibiles.client")
    if not data then
        return 0
    end
    data = fromJSON(data) or {}
    if not data[theType] then
        return 0
    end
    local now = getRealTime().timestamp
    local count = 0
    for index, collectedAt in pairs(data[theType]) do
        collectedAt = tonumber(collectedAt)
        if collectedAt then
            if (now - collectedAt) > respawn_after then
                data[theType][tostring(index)] = nil
                setAccountData(account, "collectibiles.client", toJSON(data))
                spawnClientCollectible(theType, tonumber(index), thePlayer)
            else
                count = count + 1
            end
        end
    end
    return count
end

local function respawnAllClientCollectibles()
    local playersTable = getElementsByType("player")
    for i=1, #playersTable do
        local thePlayer = playersTable[i]
        if thePlayer then
            local account = getPlayerAccount(thePlayer)
            if (account) and (not isGuestAccount(account)) then
                for theType, info in pairs(collectibleTypes) do
                    if info.target == "client" then
                        local respawn_after = info.respawn_after
                        countCollectedClient(thePlayer, account, theType, respawn_after)
                    end
                end
            end
        end
    end
end 

local function resetClientCollectibles(thePlayer, cmd, targetAccountName, theType)
    if not canManageCollectibles(thePlayer) then
        outputCustomText(thePlayer, "admin_no_permission")
        return
    end
    if not targetAccountName then
        outputCustomText(thePlayer, "command_syntax", cmd, "[target account name] (optional: [collectible type name])")
        return
    end
    if not theType then
        theType = "all"
    else
        if theType ~= "all" and not collectibleTypes[theType] then
            outputCustomText(thePlayer, "admin_invalid_collectible_type", theType)
            return
        end
    end
    local targetAccount = getAccount(targetAccountName)
    if not targetAccount then
        outputCustomText(thePlayer, "admin_invalid_account_name", targetAccountName)
        return
    end
    local data = getAccountData(targetAccount, "collectibiles.client")
    if not data then
        data = {}
    else
        data = fromJSON(data) or {}
    end
    if theType == "all" then
        data = {}
    else
        data[theType] = {}
    end
    setAccountData(targetAccount, "collectibiles.client", toJSON(data))
    local targetPlayer = nil
    local playersTable = getElementsByType("player")
    for i=1, #playersTable do
        local player = playersTable[i]
        if player then
            local account = getPlayerAccount(player)
            if (account) and (not isGuestAccount(account)) then
                if getAccountName(account) == targetAccountName then
                    targetPlayer = player
                    break
                end
            end
        end
    end
    if targetPlayer then
        sendCollectibles(targetPlayer, theType ~= "all" and theType or nil)
    end
    outputCustomText(thePlayer, "admin_reset_success", targetAccountName, theType)
end
addCommandHandler("resetcollectibles", resetClientCollectibles, false, false)

local function handlePickedUp(collectibleInfo)
    local thePlayer = source
    if not (isElement(thePlayer) and getElementType(thePlayer) == "player") then
        return
    end
    if (type(collectibleTypes)~="table") then
        return
    end
    local theType = collectibleInfo.type
    if not collectibleTypes[theType] then
        return
    end
    local account = getPlayerAccount(thePlayer)
    if (not account) or (isGuestAccount(account)) then
        return
    end
    local accountName = getAccountName(account)
    local respawn_after = collectibleTypes[theType].respawn_after
    local index = collectibleInfo.index
    local count = 0
    if not isElement(client) then
        count = countCollectedServer(accountName, theType) + 1
        collectibleTypes[theType].spawnpoints[index].collected_by = accountName
    else
        count = countCollectedClient(thePlayer, account, theType, respawn_after) + 1
        saveCollectedClient(account, accountName, theType, index)
    end
    
    local total = collectibleTypes[theType].total

    local action
    if count == total then
        action = collectibleTypes[theType].collect_all
    else
        action = collectibleTypes[theType].collect_one
    end

    -- Custom Event (for Developers)
    triggerEvent("collectibles:onCollected", thePlayer, collectibleTypes[theType].target, theType, count, total)

    if action.reward_money then
        local money = getPlayerMoney(thePlayer)
        setPlayerMoney(thePlayer, money + action.reward_money)
    end
    
    triggerClientEvent(thePlayer, "collectibles:actionOnPickedUp", thePlayer, theType, count, total, action)
end
addEventHandler("collectibles:handlePickedUp", root, handlePickedUp)

local function onPickupHit(thePlayer)
    local collectibleInfo = spawnedCollectibles[source]
    if not collectibleInfo then return end
    if (getElementDimension(thePlayer) ~= getElementDimension(source) or getElementInterior(thePlayer) ~= getElementInterior(source)) then return end
    destroyElement(source)
    spawnedCollectibles[source] = nil
    triggerEvent("collectibles:handlePickedUp", thePlayer, collectibleInfo)
end
addEventHandler("onPickupHit", resourceRoot, onPickupHit)

addEventHandler("onPickupHit", resourceRoot, function()
    cancelEvent()
end)

addEventHandler("onPlayerResourceStart", root, function(res)
    if res == resource then
        if type(clientsWaiting)=="table" then
            clientsWaiting[#clientsWaiting+1] = source
        else
            sendCollectibles(source)
        end
    end
end)

addEventHandler("onResourceStart", resourceRoot, function()

    local success, reason = loadConfiguration()
    if not success then
        outputInfoMessage(reason)
        outputInfoMessage("Restore the backed up configuration file 'config.xml.backup' if needed.")
        return cancelEvent()
    end

    outputInfoMessage("Successfully loaded configuration.")
    
    createServerCollectibles()

    for i=1, #clientsWaiting do
        local player = clientsWaiting[i]
        if player then
            sendCollectibles(player)
        end
    end

    clientsWaiting = nil

    setTimer(respawnAllClientCollectibles, 60000, 0)
end)
