--[[
    Author: https://github.com/Fernando-A-Rocha

    Collectibles - System (Server)

    Administrative commmands:
        - /resetcollectibles

    /!\ Unless you know what you are doing, do not edit this file. /!\
]]

-- Internal Events
addEvent("collectibles:requestCollectibles", true) -- source: always resourceRoot
addEvent("collectibles:handlePickedUp", true) -- source: root or a player element

-- Custom Events (for Developers)
addEvent("collectibles:onCollected", true) -- source: a player element
addEvent("collectibles:onSpawnedServer", true) -- source: always root
addEvent("collectibles:onDestroyedServer", true) -- source: always root

local clientsWaiting = {} -- initial startup
local collectibleTypes = {}
local spawnedServerCollectibles = {}

function getAccountDataNames()
    return {
        client_counts = "collectibiles.client",
    }
end

--- **(Exported)**
function getCollectibleTypes()
    return collectibleTypes
end

function getConstants()
    return CONSTANTS
end

function getSpawnedServerCollectibles()
    return spawnedServerCollectibles
end

function outputInfoMessage(msg)
    msg = "[Collectibles] " .. msg
    outputServerLog(msg)
end

local function parseOneNode(rootChildren, targetNodeName)

    local KEY_NAMES = { "mouse1", "mouse2", "mouse3", "mouse4", "mouse5", "mouse_wheel_up", "mouse_wheel_down", "arrow_l", "arrow_u", --escape
    "arrow_r", "arrow_d", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k",
    "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "num_0", "num_1", "num_2", "num_3", "num_4", "num_5",
    "num_6", "num_7", "num_8", "num_9", "num_mul", "num_add", "num_sep", "num_sub", "num_div", "num_dec", "num_enter", "F1", "F2", "F3", "F4", "F5",
    "F6", "F7", "F8", "F9", "F10", "F11", "F12", "backspace", "tab", "lalt", "ralt", "enter", "space", "pgup", "pgdn", "end", "home",
    "insert", "delete", "lshift", "rshift", "lctrl", "rctrl", "[", "]", "pause", "capslock", "scroll", ";", ",", "-", ".", "/", "#", "\\", "=" }

    for i=1, #rootChildren do
        local node = rootChildren[i]
        if node then
            local nodeName = xmlNodeGetName(node)
            if targetNodeName == nodeName then
                if nodeName == "types" then
                    local children = xmlNodeGetChildren(node)
                    if not children then
                        return false, "Failed to get children of 'types' node."
                    end
                    for j=1, #children do
                        local child = children[j]
                        if child then
                            local childName = xmlNodeGetName(child)
                            if childName ~= "type" then
                                return false, "Invalid child node '" .. childName .. "' of 'types' node."
                            end
                            local name = xmlNodeGetAttribute(child, "name")
                            if not name then
                                return false, "Missing attribute 'name' of 'type' node."
                            end
                            if collectibleTypes[name] then
                                return false, "Duplicate collectible type '" .. name .. "'."
                            end
                            if name == "all" then
                                return false, "Collectible type name 'all' is not allowed."
                            end
                            if string.find(name, " ") then
                                return false, "Collectible type name '" .. name .. "' is not allowed - replace spaces with '_'."
                            end
                            local target = xmlNodeGetAttribute(child, "target")
                            if (not target) then
                                return false, "Missing attribute 'target' of 'type' node."
                            end
                            if not (target == "client" or target == "server") then
                                return false, "Invalid attribute 'target' of 'type' node, expected client/server."
                            end
                            local toggle_keybind = xmlNodeGetAttribute(child, "toggle_keybind") or false
                            local toggle_command = xmlNodeGetAttribute(child, "toggle_command") or false
                            if ((toggle_command or toggle_keybind) and target=="server") then
                                return false, "'toggle_keybind' or 'toggle_command' are only for client-side collectibles."
                            end
                            if toggle_command and toggle_command == "" then
                                return false, "Invalid attribute 'toggle_command' of 'type' node, can't be empty."
                            end
                            if toggle_keybind then
                                if toggle_keybind == "" then
                                    return false, "Invalid attribute 'toggle_keybind' of 'type' node, can't be empty."
                                end
                                toggle_keybind = string.lower(toggle_keybind)
                                local found = false
                                for w=1, #KEY_NAMES do
                                    if toggle_keybind == string.lower(KEY_NAMES[w]) then
                                        found = true
                                        break
                                    end
                                end
                                if not found then
                                    return false, "Invalid attribute 'toggle_keybind' of 'type' node, unknown key name."
                                end
                            end
                            local auto_load = xmlNodeGetAttribute(child, "auto_load") or false
                            if auto_load and auto_load ~= "true" and auto_load ~= "false" then
                                return false, "Invalid attribute 'auto_load' of 'type' node, expected true/false."
                            end
                            if auto_load == "true" then
                                auto_load = true
                            else
                                auto_load = false
                            end
                            local respawn_after = xmlNodeGetAttribute(child, "respawn_after") or false
                            local respawn_after_converted
                            local respawn_after_unit = xmlNodeGetAttribute(child, "respawn_after_unit") or false
                            if (target=="client" and respawn_after) then
                                respawn_after = tonumber(respawn_after)
                                if (not respawn_after) or (respawn_after < 0) then
                                    return false, "Invalid attribute 'respawn_after' of 'type' node - must be a number greater than 0."
                                end
                                if not (respawn_after_unit == "seconds"
                                or respawn_after_unit == "minutes"
                                or respawn_after_unit == "hours"
                                or respawn_after_unit == "days"
                                or respawn_after_unit == "weeks") then
                                    return false, "Invalid attribute 'respawn_after_unit' of 'type' node - must be seconds/minutes/hours/days/weeks."
                                end
                                -- convert to seconds
                                respawn_after_converted = respawn_after
                                if respawn_after_unit == "minutes" then
                                    respawn_after_converted = respawn_after_converted * 60
                                elseif respawn_after_unit == "hours" then
                                    respawn_after_converted = respawn_after_converted * 60 * 60
                                elseif respawn_after_unit == "days" then
                                    respawn_after_converted = respawn_after_converted * 60 * 60 * 24
                                elseif respawn_after_unit == "weeks" then
                                    respawn_after_converted = respawn_after_converted * 60 * 60 * 24 * 7
                                end
                            end
                            collectibleTypes[name] = {
                                target = target,
                                auto_load = auto_load,

                                -- client only:
                                toggle_keybind = toggle_keybind,
                                toggle_command = toggle_command,
                                respawn_after = respawn_after_converted,
                                respawn_after_nonconverted = respawn_after,
                                respawn_after_unit = respawn_after_unit,
                            }
                        end
                    end
                elseif nodeName == "actions" then
                    local children = xmlNodeGetChildren(node)
                    if not children then
                        return false, "Failed to get children of 'actions' node."
                    end
                    for j=1, #children do
                        local child = children[j]
                        if child then
                            local childName = xmlNodeGetName(child)
                            if childName ~= "action" then
                                return false, "Invalid child node '" .. childName .. "' of 'actions' node."
                            end
                            local theType = xmlNodeGetAttribute(child, "type")
                            if not theType then
                                return false, "Missing attribute 'type' of 'action' node."
                            end
                            local collectibleType = collectibleTypes[theType]
                            if not collectibleType then
                                return false, "Invalid type '" .. theType .. "' of 'action' node."
                            end
                            local on = xmlNodeGetAttribute(child, "on")
                            if not on then
                                return false, "Missing attribute 'on' of 'action' node."
                            end
                            if not (on == "collect_one" or on == "collect_all") then
                                return false, "Invalid attribute 'on' of 'action' node."
                            end
                            local sound = xmlNodeGetAttribute(child, "sound") or false
                            local sound_volume = xmlNodeGetAttribute(child, "sound_volume")
                            if sound then
                                if not fileExists(sound) then
                                    return false, "Invalid attribute 'sound' of 'action' node - file does not exist."
                                end
                                sound_volume = tonumber(sound_volume)
                                if (not sound_volume) or (sound_volume < 0) then
                                    return false, "Invalid attribute 'sound_volume' of 'action' node - must be a number greater than 0."
                                end
                            end
                            local reward_money = xmlNodeGetAttribute(child, "reward_money") or false
                            if reward_money then
                                reward_money = tonumber(reward_money)
                                if (not reward_money) or (reward_money < 0) then
                                    return false, "Invalid attribute 'reward_money' of 'action' node - must be a number greater than 0."
                                end
                            end
                            collectibleTypes[theType][on] = {
                                sound = sound,
                                sound_volume = sound_volume,
                                reward_money = reward_money,
                            }
                        end
                    end
                elseif nodeName == "spawnpoints" then
                    local children = xmlNodeGetChildren(node)
                    if not children then
                        return false, "Failed to get children of 'spawnpoints' node."
                    end
                    for j=1, #children do
                        local child = children[j]
                        if child then
                            local childName = xmlNodeGetName(child)
                            if childName ~= "spawnpoint" then
                                return false, "Invalid child node '" .. childName .. "' of 'spawnpoints' node."
                            end
                            local theType = xmlNodeGetAttribute(child, "type")
                            if not theType then
                                return false, "Missing attribute 'type' of 'spawnpoint' node."
                            end
                            local id = xmlNodeGetAttribute(child, "id")
                            id = tonumber(id)
                            if (not id) or (id < 0) then
                                return false, "Invalid attribute 'id' of 'spawnpoint' node - must be a number greater than 0."
                            end
                            local x = xmlNodeGetAttribute(child, "x")
                            if not x then
                                return false, "Missing attribute 'x' of 'spawnpoint' node."
                            end
                            x = tonumber(x)
                            if (not x) then
                                return false, "Invalid attribute 'x' of 'spawnpoint' node - must be a number."
                            end
                            local y = xmlNodeGetAttribute(child, "y")
                            if not y then
                                return false, "Missing attribute 'y' of 'spawnpoint' node."
                            end
                            y = tonumber(y)
                            if (not y) then
                                return false, "Invalid attribute 'y' of 'spawnpoint' node - must be a number."
                            end
                            local z = xmlNodeGetAttribute(child, "z")
                            if not z then
                                return false, "Missing attribute 'z' of 'spawnpoint' node."
                            end
                            z = tonumber(z)
                            if (not z) then
                                return false, "Invalid attribute 'z' of 'spawnpoint' node - must be a number."
                            end
                            local interior = xmlNodeGetAttribute(child, "interior") or 0
                            interior = tonumber(interior)
                            if (not interior) or (interior < 0) then
                                return false, "Invalid attribute 'interior' of 'spawnpoint' node - must be a number greater than 0."
                            end
                            local dimension = xmlNodeGetAttribute(child, "dimension") or 0
                            dimension = tonumber(dimension)
                            if (not dimension) or (dimension < 0) then
                                return false, "Invalid attribute 'dimension' of 'spawnpoint' node - must be a number greater than 0."
                            end
                            local model = xmlNodeGetAttribute(child, "model")
                            if not model then
                                return false, "Missing attribute 'model' of 'spawnpoint' node."
                            end
                            model = tonumber(model)
                            if (not model) or (model < 0) then
                                return false, "Invalid attribute 'model' of 'spawnpoint' node - must be a number greater than 0."
                            end
                            local testPickup = createPickup(x, y, z, 3, model)
                            if not testPickup then
                                destroyElement(testPickup)
                                return false, "Invalid attribute 'model' of 'spawnpoint' node - invalid object model ID."
                            end
                            destroyElement(testPickup)
                            for theType2, info in pairs(collectibleTypes) do
                                if info.spawnpoints then
                                    for w=1, #info.spawnpoints do
                                        local spawnpoint = info.spawnpoints[w]
                                        if spawnpoint and spawnpoint.x == x and spawnpoint.y == y and spawnpoint.z == z then
                                            return false, "Duplicate spawnpoint at position " .. x .. ", " .. y .. ", " .. z .. "."
                                        end
                                    end
                                end
                            end
                            if not collectibleTypes[theType].spawnpoints then
                                collectibleTypes[theType].spawnpoints = {}
                            end
                            for w=1, #collectibleTypes[theType].spawnpoints do
                                local spawnpoint = collectibleTypes[theType].spawnpoints[w]
                                if spawnpoint and spawnpoint.spID == id then
                                    return false, "Duplicate spawnpoint ID '" .. id .. "' for type '" .. theType .. "'."
                                end
                            end
                            local newIndex = #collectibleTypes[theType].spawnpoints + 1
                            collectibleTypes[theType].spawnpoints[newIndex] = {
                                spID = id,
                                x = x,
                                y = y,
                                z = z,
                                interior = interior,
                                dimension = dimension,
                                model = model,
                            }
                        end
                    end
                end
            end
        end
    end
    return true
end

local function commandSpawnCollectibles(thePlayer, cmd, theType)
    if not canAdminCollectibles(thePlayer) then
        outputCustomText(thePlayer, "admin_no_permission")
        return
    end
    if not theType then
        outputCustomText(thePlayer, "command_syntax", cmd, "[collectible type]")
        return
    end
    spawnCollectibles(theType, thePlayer)
end

local function commandDestroyCollectibles(thePlayer, cmd, theType)
    if not canAdminCollectibles(thePlayer) then
        outputCustomText(thePlayer, "admin_no_permission")
        return
    end
    if not theType then
        outputCustomText(thePlayer, "command_syntax", cmd, "[collectible type]")
        return
    end
    destroyCollectibles(theType, thePlayer)
end

local function commandResetCollectibles(thePlayer, cmd, targetAccountID, theType)
    if not canAdminCollectibles(thePlayer) then
        outputCustomText(thePlayer, "admin_no_permission")
        return
    end
    targetAccountID = tonumber(targetAccountID)
    if not targetAccountID then
        outputCustomText(thePlayer, "command_syntax", cmd, "[target account ID] (optional: [collectible type name])")
        return
    end
    local targetAccount = getAccountByID(targetAccountID)
    if not targetAccount then
        outputCustomText(thePlayer, "admin_invalid_account_id", tostring(targetAccount))
        return
    end
    if not theType then
        theType = "all"
    end
    resetClientCollectibles(targetAccount, theType, thePlayer)
end

local function commandCreateSpawnpoint(thePlayer, cmd, theType, model)
    if not canAdminCollectibles(thePlayer) then
        outputCustomText(thePlayer, "admin_no_permission")
        return
    end
    model = tonumber(model)
    if not theType or not model then
        outputCustomText(thePlayer, "command_syntax", cmd, "[collectible type] [pickup object model ID]")
        return
    end
    if not collectibleTypes[theType] then
        outputCustomText(thePlayer, "admin_invalid_collectible_type", theType)
        return
    end
    if not isDefaultObjectID(model) then
        outputCustomText(thePlayer, "admin_invalid_object_model_id", tostring(model))
        return
    end
    local x,y,z = getElementPosition(thePlayer)
    local interior, dimension = getElementInterior(thePlayer), getElementDimension(thePlayer)
    setPlayerPreventPicking(thePlayer, 5000)
    local newSpID, reason = createNewSpawnpoint(theType, model, x,y,z, interior, dimension)
    if not newSpID then
        outputCustomText(thePlayer, "admin_error", reason)
        return
    end
    outputCustomText(thePlayer, "admin_spawnpoint_created", tostring(newSpID), (string.gsub(theType, "_", " ")))
end

local function commandRemoveSpawnpoint(thePlayer, cmd, theType, spID)
    if not canAdminCollectibles(thePlayer) then
        outputCustomText(thePlayer, "admin_no_permission")
        return
    end
    spID = tonumber(spID)
    if not theType or not spID then
        outputCustomText(thePlayer, "command_syntax", cmd, "[collectible type] [spawnpoint ID]")
        return
    end
    if not collectibleTypes[theType] then
        outputCustomText(thePlayer, "admin_invalid_collectible_type", theType)
        return
    end
    if #collectibleTypes[theType].spawnpoints == 0 then
        outputCustomText(thePlayer, "admin_no_spawnpoints", (string.gsub(theType, "_", " ")))
        return
    end
    for i=1, #collectibleTypes[theType].spawnpoints do
        local spawnpoint = collectibleTypes[theType].spawnpoints[i]
        if spawnpoint and spawnpoint.spID == spID then
            local success, reason = removeSpawnpoint(theType, spID)
            if not success then
                outputCustomText(thePlayer, "admin_error", reason)
                return
            end
            outputCustomText(thePlayer, "admin_removed_spawnpoint", tostring(spID), (string.gsub(theType, "_", " ")))
            return
        end
    end
    outputCustomText(thePlayer, "admin_invalid_spawnpoint_id", (string.gsub(theType, "_", " ")), spID)
end

--- Validates all custom settings
--
--- returns true if successful, false + error message otherwise.
local function parseCustomSettings()

    --[[
        CUSTOM FUNCTIONS
    --]]
    if type(canAdminCollectibles) ~= "function" then
        return false, "Failed to parse custom settings - canAdminCollectibles is not a function."
    end
    if type(canCollectPickup) ~= "function" then
        return false, "Failed to parse custom settings - canCollectPickup is not a function."
    end

    --[[
        CONSTANTS TABLE
    --]]
    if type(CONSTANTS) ~= "table" then
        return false, "Failed to parse constants - CONSTANTS is not a table."
    end

    -- COMMANDS
    if type(CONSTANTS.COMMANDS) ~= "table" then
        return false, "Failed to parse constants - CONSTANTS.COMMANDS is not a table."
    end

    local commands = CONSTANTS.COMMANDS
    if type(commands.SPAWN) ~= "string" then
        return false, "Failed to parse constants - CONSTANTS.COMMANDS.SPAWN is not a string."
    end
    addCommandHandler(commands.SPAWN, commandSpawnCollectibles, false, false)

    if type(commands.DESTROY) ~= "string" then
        return false, "Failed to parse constants - CONSTANTS.COMMANDS.DESTROY is not a string."
    end
    addCommandHandler(commands.DESTROY, commandDestroyCollectibles, false, false)

    if type(commands.RESETPLAYER) ~= "string" then
        return false, "Failed to parse constants - CONSTANTS.COMMANDS.RESETPLAYER is not a string."
    end
    addCommandHandler(commands.RESETPLAYER, commandResetCollectibles, false, false)

    if type(commands.CREATESPAWN) ~= "string" then
        return false, "Failed to parse constants - CONSTANTS.COMMANDS.CREATESPAWN is not a string."
    end
    addCommandHandler(commands.CREATESPAWN, commandCreateSpawnpoint, false, false)

    if type(commands.REMOVESPAWN) ~= "string" then
        return false, "Failed to parse constants - CONSTANTS.COMMANDS.REMOVESPAWN is not a string."
    end
    addCommandHandler(commands.REMOVESPAWN, commandRemoveSpawnpoint, false, false)

    -- Optional Commands
    if (CONFIG_EDITOR_LOADED) then
        if type(commands.SPAWNPOINTS) ~= "string" then
            return false, "Failed to parse constants - CONSTANTS.COMMANDS.SPAWNPOINTS is not a string."
        end
        addCommandHandler(commands.SPAWNPOINTS, commandConfigureSpawnpoints, false, false)

        if type(commands.EDITOR) ~= "string" then
            return false, "Failed to parse constants - CONSTANTS.COMMANDS.EDITOR is not a string."
        end
        addCommandHandler(commands.EDITOR, commandOpenEditor, false, false)
    end

    -- STRINGS
    if type(CONSTANTS.STRINGS) ~= "table" then
        return false, "Failed to parse constants - CONSTANTS.STRINGS is not a table."
    end

    return true
end

--- Loads the configuration file and parses it
--
-- Errors are usually caused by incorrectly formatted XML file (caused by editing it manually) and file IO operations.
local function loadConfiguration()

    local config = xmlLoadFile("config.xml")
    if not config then
        return false, "Failed to load file 'config.xml'."
    end

    local children = xmlNodeGetChildren(config)
    if not children then
        xmlUnloadFile(config)
        return false, "Failed to get children of 'config.xml'."
    end

    local success, reason, theType = parseOneNode(children, "types")
    if not success then
        xmlUnloadFile(config)
        return false, "Failed to parse <types>: " .. reason
    end
    success, reason = parseOneNode(children, "actions")
    if not success then
        xmlUnloadFile(config)
        return false, "Failed to parse <actions>: " .. reason
    end
    for theType2, info2 in pairs(collectibleTypes) do
        if not info2.collect_one then
            xmlUnloadFile(config)
            return false, "Missing action 'collect_one' for type '" .. theType2 .. "'."
        end
        if not info2.collect_all then
            xmlUnloadFile(config)
            return false, "Missing action 'collect_all' for type '" .. theType2 .. "'."
        end
    end
    success, reason = parseOneNode(children, "spawnpoints")
    if not success then
        xmlUnloadFile(config)
        return false, "Failed to parse <spawnpoints>: " .. reason
    end
    for theType2, info2 in pairs(collectibleTypes) do
        if not info2.spawnpoints then
            collectibleTypes[theType2].spawnpoints = {}
        end
        collectibleTypes[theType2].total = #collectibleTypes[theType2].spawnpoints
    end

    xmlUnloadFile(config)
    return true
end

function backupConfiguration()
    if fileExists("backups/config.xml") then
        if not fileDelete("backups/config.xml") then
            return false, "Failed to delete file 'backups/config.xml' - check permissions."
        end
    end
    local backup = fileCreate("backups/config.xml")
    if not backup then
        return false, "Failed to create file 'backups/config.xml' - check permissions."
    end
    local config = fileOpen("config.xml")
    if not config then
        fileClose(backup)
        return false, "Failed to open file 'config.xml' - check permissions."
    end
    fileWrite(backup, fileRead(config, fileGetSize(config)))
    fileClose(config)
    fileClose(backup)
    return true
end

function duplicateConfigBackup(newPath)
    if not fileExists("backups/config.xml") then
        return false, "File 'backups/config.xml' does not exist."
    end
    if fileExists(newPath) then
        return false, "File '" .. newPath .. "' already exists, will not override."
    end
    local new = fileCreate(newPath)
    if not new then
        return false, "Failed to create file '" .. newPath .. "' - check permissions."
    end
    local backup = fileOpen("backups/config.xml")
    if not backup then
        fileClose(new)
        return false, "Failed to open file 'backups/config.xml' - check permissions."
    end
    fileWrite(new, fileRead(backup, fileGetSize(backup)))
    fileClose(backup)
    fileClose(new)
    return true
end

function restoreConfigBackup()
    if fileExists("config.xml.old") then
        if not fileDelete("config.xml.old") then
            return false, "Failed to delete file 'config.xml.old' - check permissions."
        end
    end
    local old = fileCreate("config.xml.old")
    if not old then
        return false, "Failed to create file 'config.xml.old' - check permissions."
    end
    local config = fileOpen("config.xml")
    if not config then
        fileClose(old)
        return false, "Failed to open file 'config.xml' - check permissions."
    end
    fileWrite(old, fileRead(config, fileGetSize(config)))
    fileClose(config)
    fileClose(old)
    if not fileCopy("backups/config.xml", "config.xml", true) then -- Overwrite
        return false, "Failed to copy file 'backups/config.xml' to 'config.xml' - check permissions."
    end
    return true
end

local function findNode(theChildren, nodeName, attributeNames)
    for i=1, #theChildren do
        local child = theChildren[i]
        if xmlNodeGetName(child) == nodeName then
            local nodeChildren = xmlNodeGetChildren(child)
            if not nodeChildren then
                return false, "Failed to get children of '" .. nodeName .. "' in 'config.xml'."
            end
            for j=1, #nodeChildren do
                local nodeChild = nodeChildren[j]
                if nodeChild then
                    local matches = true
                    for attrName, withAttrName in pairs(attributeNames) do
                        if xmlNodeGetAttribute(nodeChild, attrName) ~= withAttrName then
                            matches = false
                            break
                        end
                    end
                    if matches then
                        return nodeChild
                    end
                end
            end
        end
    end
    return false, "Failed to find node '" .. nodeName .. "/" .. inspect(attributeNames) .. "' in 'config.xml'."
end

function updateConfiguration(updateNodes)
    assert(type(updateNodes) == "table", "Bad argument @ updateConfiguration (table expected, got " .. type(updateNodes) .. ")")

    local config = xmlLoadFile("config.xml")
    if not config then
        return false, "Failed to load file 'config.xml'."
    end

    local children = xmlNodeGetChildren(config)
    if not children then
        xmlUnloadFile(config)
        return false, "Failed to get children of 'config.xml'."
    end

    local updatedTypeNames = {} -- old => new
    for settingType, list in pairs(updateNodes) do
        for name, info in pairs(list) do
            if type(info.attributes)=="table" then
                for attrName, attrValue in pairs(info.attributes) do
                    if settingType == "types" and attrName == "name" then
                        updatedTypeNames[name] = attrValue
                    end
                end
            end
        end
    end

    for settingType, list in pairs(updateNodes) do
        for name, info in pairs(list) do
            local attributeNames = info.attributeNames
            if type(attributeNames)=="table" then
                local node, failFindReason = findNode(children, settingType, attributeNames)
                if not node then
                    xmlUnloadFile(config)
                    return false, failFindReason
                end
                if type(info.value)=="string" then
                    xmlNodeSetValue(node, info.value)
                end
                if type(info.attributes)=="table" then
                    for attrName, attrValue in pairs(info.attributes) do
                        if attrValue == false then
                            xmlNodeSetAttribute(node, tostring(attrName), nil)
                        else
                            xmlNodeSetAttribute(node, tostring(attrName), tostring(attrValue))
                        end
                    end
                end
            end
        end
    end

    children = xmlNodeGetChildren(config)
    if not children then
        xmlUnloadFile(config)
        return false, "Failed to get children of 'config.xml'."
    end

    for i=1, #children do
        local child = children[i]
        if xmlNodeGetName(child) == "actions" or xmlNodeGetName(child) == "spawnpoints" then
            local nodeChildren = xmlNodeGetChildren(child)
            if not nodeChildren then
                xmlUnloadFile(config)
                return false, "Failed to get children of '" .. xmlNodeGetName(child) .. "' in 'config.xml'."
            end
            for j=1, #nodeChildren do
                local nodeChild = nodeChildren[j]
                local typeName = xmlNodeGetAttribute(nodeChild, "type")
                if typeName and updatedTypeNames[typeName] then
                    xmlNodeSetAttribute(nodeChild, "type", updatedTypeNames[typeName])
                end
            end
        end
    end

    if not xmlSaveFile(config) then
        xmlUnloadFile(config)
        return false, "Failed to save file 'config.xml'."
    end

    xmlUnloadFile(config)
    return true
end

function deleteType(theType)
    assert(type(theType) == "string", "Bad argument @ deleteType (string expected, got " .. type(theType) .. ")")
    local info = collectibleTypes[theType]
    if not info then
        return false, "Failed to delete type '" .. theType .. "' - type does not exist."
    end

    local config = xmlLoadFile("config.xml")
    if not config then
        return false, "Failed to load file 'config.xml'."
    end

    local children = xmlNodeGetChildren(config)
    if not children then
        xmlUnloadFile(config)
        return false, "Failed to get children of 'config.xml'."
    end

    -- Find the necessary node
    local typesNode, actionsNode, spawnpointsNode
    for i=1, #children do
        local child = children[i]
        if xmlNodeGetName(child) == "types" then
            typesNode = child
        elseif xmlNodeGetName(child) == "actions" then
            actionsNode = child
        elseif xmlNodeGetName(child) == "spawnpoints" then
            spawnpointsNode = child
        end
    end

    if not typesNode then
        xmlUnloadFile(config)
        return false, "Failed to find node 'types' in 'config.xml'."
    end
    if not actionsNode then
        xmlUnloadFile(config)
        return false, "Failed to find node 'actions' in 'config.xml'."
    end
    if not spawnpointsNode then
        xmlUnloadFile(config)
        return false, "Failed to find node 'spawnpoints' in 'config.xml'."
    end

    local typesChildren = xmlNodeGetChildren(typesNode)
    if not typesChildren then
        xmlUnloadFile(config)
        return false, "Failed to get children of 'types' in 'config.xml'."
    end

    local actionsChildren = xmlNodeGetChildren(actionsNode)
    if not actionsChildren then
        xmlUnloadFile(config)
        return false, "Failed to get children of 'actions' in 'config.xml'."
    end

    local spawnpointsChildren = xmlNodeGetChildren(spawnpointsNode)
    if not spawnpointsChildren then
        xmlUnloadFile(config)
        return false, "Failed to get children of 'spawnpoints' in 'config.xml'."
    end

    local typeNode = nil
    local actionNodes, spawnpointNodes = {}, {}
    for i=1, #typesChildren do
        local child = typesChildren[i]
        if xmlNodeGetName(child) == "type" then
            local name = xmlNodeGetAttribute(child, "name")
            if name == theType then
                typeNode = child
                break
            end
        end
    end
    if not typeNode then
        xmlUnloadFile(config)
        return false, "Failed to find node 'type' with attribute 'name' = '" .. theType .. "' in 'config.xml'."
    end

    for i=1, #actionsChildren do
        local child = actionsChildren[i]
        if xmlNodeGetName(child) == "action" then
            local typeName = xmlNodeGetAttribute(child, "type")
            if typeName == theType then
                actionNodes[#actionNodes+1] = child
            end
        end
    end
    if #actionNodes ~= 2 then
        xmlUnloadFile(config)
        return false, "Failed to find 2 'action' nodes with attribute 'type' = '" .. theType .. "' in 'config.xml'."
    end

    for i=1, #spawnpointsChildren do
        local child = spawnpointsChildren[i]
        if xmlNodeGetName(child) == "spawnpoint" then
            local typeName = xmlNodeGetAttribute(child, "type")
            if typeName == theType then
                spawnpointNodes[#spawnpointNodes+1] = child
            end
        end
    end

    -- Delete the nodes
    xmlDestroyNode(typeNode)
    for i=1, #actionNodes do
        xmlDestroyNode(actionNodes[i])
    end
    for i=1, #spawnpointNodes do
        if spawnpointNodes[i] then
            xmlDestroyNode(spawnpointNodes[i])
        end
    end

    if info.target == "client" then

        -- reset all accounts' collected counts of this type
        local accounts = getAccounts()
        local collectedCounts = {}
        for i=1, #accounts do
            local account = accounts[i]
            if account then
                local dataName = getAccountDataNames().client_counts
                local data = getAccountData(account, dataName)
                if not data then
                    data = {}
                else
                    data = fromJSON(data) or {}
                end
                data[theType] = nil
                setAccountData(account, dataName, toJSON(data))
            end
        end
    end

    if not xmlSaveFile(config) then
        xmlUnloadFile(config)
        return false, "Failed to save file 'config.xml'."
    end

    xmlUnloadFile(config)
    return true
end

function createNewType(typeInfo)
    assert(type(typeInfo) == "table", "Bad argument @ createNewType (table expected, got " .. type(typeInfo) .. ")")

    local config = xmlLoadFile("config.xml")
    if not config then
        return false, "Failed to load file 'config.xml'."
    end

    local children = xmlNodeGetChildren(config)
    if not children then
        xmlUnloadFile(config)
        return false, "Failed to get children of 'config.xml'."
    end

    -- Verify type info

    local newName = typeInfo.name
    if type(newName) ~= "string" then
        xmlUnloadFile(config)
        return false, "Failed to create new type - no name specified."
    end

    if type(typeInfo.auto_load) ~= "string" then
        xmlUnloadFile(config)
        return false, "Failed to create new type - no auto_load specified."
    end

    if type(typeInfo.target) ~= "string" then
        xmlUnloadFile(config)
        return false, "Failed to create new type - no target specified."
    end

    if type(typeInfo.actions) ~= "table" then
        xmlUnloadFile(config)
        return false, "Failed to create new type - no actions specified."
    end

    if type(typeInfo.actions.collect_one) ~= "table" then
        xmlUnloadFile(config)
        return false, "Failed to create new type - no collect_one actions specified."
    end

    if type(typeInfo.actions.collect_all) ~= "table" then
        xmlUnloadFile(config)
        return false, "Failed to create new type - no collect_all actions specified."
    end

    -- Check if type with that name already exists
    if findNode(children, "types", {name=newName}) then
        xmlUnloadFile(config)
        return false, "Failed to create new type - type with name '" .. newName .. "' already exists."
    end

    -- Find the necessary node
    local typesNode, actionsNode
    for i=1, #children do
        local child = children[i]
        if xmlNodeGetName(child) == "types" then
            typesNode = child
        elseif xmlNodeGetName(child) == "actions" then
            actionsNode = child
        end
    end

    if not typesNode then
        xmlUnloadFile(config)
        return false, "Failed to find node 'types' in 'config.xml'."
    end
    if not actionsNode then
        xmlUnloadFile(config)
        return false, "Failed to find node 'actions' in 'config.xml'."
    end

    -- Create new type node

    local newTypeNode = xmlCreateChild(typesNode, "type")
    if not newTypeNode then
        xmlUnloadFile(config)
        return false, "Failed to create new type node."
    end

    xmlNodeSetAttribute(newTypeNode, "name", newName)
    xmlNodeSetAttribute(newTypeNode, "auto_load", typeInfo.auto_load)
    xmlNodeSetAttribute(newTypeNode, "target", typeInfo.target)

    if typeInfo.respawn_after ~= nil then
        if type(typeInfo.respawn_after) ~= "string" then
            xmlUnloadFile(config)
            return false, "Failed to create new type - respawn_after must be a string."
        end
        if type(typeInfo.respawn_after_unit) ~= "string" then
            xmlUnloadFile(config)
            return false, "Failed to create new type - respawn_after_unit must be a string."
        end
        xmlNodeSetAttribute(newTypeNode, "respawn_after", typeInfo.respawn_after)
        xmlNodeSetAttribute(newTypeNode, "respawn_after_unit", typeInfo.respawn_after_unit)
    end
    if typeInfo.toggle_command ~= nil then
        if type(typeInfo.toggle_command) ~= "string" then
            xmlUnloadFile(config)
            return false, "Failed to create new type - toggle_command must be a string."
        end
        xmlNodeSetAttribute(newTypeNode, "toggle_command", typeInfo.toggle_command)
    end
    if typeInfo.toggle_key_bind ~= nil then
        if type(typeInfo.toggle_key_bind) ~= "string" then
            xmlUnloadFile(config)
            return false, "Failed to create new type - toggle_key_bind must be a string."
        end
        xmlNodeSetAttribute(newTypeNode, "toggle_key_bind", typeInfo.toggle_key_bind)
    end

    -- Create 2 action nodes

    local newActionNodeOne = xmlCreateChild(actionsNode, "action")
    if not newActionNodeOne then
        xmlUnloadFile(config)
        return false, "Failed to create new action node."
    end

    xmlNodeSetAttribute(newActionNodeOne, "type", newName)
    xmlNodeSetAttribute(newActionNodeOne, "on", "collect_one")

    if typeInfo.actions.collect_one.sound ~= nil then
        if type(typeInfo.actions.collect_one.sound) ~= "string" then
            xmlUnloadFile(config)
            return false, "Failed to create new type - collect_one sound must be a string."
        end
        if type(typeInfo.actions.collect_one.sound_volume) ~= "string" then
            xmlUnloadFile(config)
            return false, "Failed to create new type - collect_one sound_volume must be a string."
        end
        xmlNodeSetAttribute(newActionNodeOne, "sound_volume", typeInfo.actions.collect_one.sound_volume)
    end

    local newActionNodeAll = xmlCreateChild(actionsNode, "action")
    if not newActionNodeAll then
        xmlUnloadFile(config)
        return false, "Failed to create new action node."
    end

    xmlNodeSetAttribute(newActionNodeAll, "type", newName)
    xmlNodeSetAttribute(newActionNodeAll, "on", "collect_all")

    if typeInfo.actions.collect_all.sound ~= nil then
        if type(typeInfo.actions.collect_all.sound) ~= "string" then
            xmlUnloadFile(config)
            return false, "Failed to create new type - collect_all sound must be a string."
        end
        if type(typeInfo.actions.collect_all.sound_volume) ~= "string" then
            xmlUnloadFile(config)
            return false, "Failed to create new type - collect_all sound_volume must be a string."
        end
        xmlNodeSetAttribute(newActionNodeAll, "sound_volume", typeInfo.actions.collect_all.sound_volume)
    end

    if not xmlSaveFile(config) then
        xmlUnloadFile(config)
        return false, "Failed to save file 'config.xml'."
    end

    xmlUnloadFile(config)
    return true
end

local function createOnePickup(theType, spID, spawnpoint)
    local pickup = createPickup(spawnpoint.x, spawnpoint.y, spawnpoint.z, 3, spawnpoint.model)
    if not pickup then
        outputInfoMessage("Failed to create pickup for type '" .. theType .. "' at spawnpoint " .. (spID) .. ".", "ERROR")
        return false
    end
    setElementInterior(pickup, spawnpoint.interior)
    setElementDimension(pickup, spawnpoint.dimension)
    spawnedServerCollectibles[pickup] = {
        type = theType,
        spID = spID,
    }
    return pickup
end

--- **(Exported)**
function spawnCollectibles(theType, thePlayer)
    assert(type(theType) == "string", "Bad argument @ spawnCollectibles [expected string at argument 1, got " .. type(theType) .. "]")
    local info = collectibleTypes[theType]
    if (not info) or (info.target ~= "server") then
        if isElement(thePlayer) then
            outputCustomText(thePlayer, "admin_invalid_collectible_type", theType)
            for theType2, info2 in pairs(collectibleTypes) do
                if info2.target == "server" then
                    outputChatBox("  - " .. theType2, thePlayer, 255, 255, 255)
                end
            end
        end
        return false, "admin_invalid_collectible_type"
    end
    local countExisting = 0
    for pickup, info2 in pairs(spawnedServerCollectibles) do
        if info2.type == theType then
            countExisting = countExisting + 1
        end
    end
    if countExisting > 0 then
        if isElement(thePlayer) then
            outputCustomText(thePlayer, "admin_count_spawned", countExisting, (string.gsub(theType, "_", " ")))
        end
        return false, "admin_count_spawned"
    end
    for i=1, #info.spawnpoints do
        local sp = info.spawnpoints[i]
        if sp then
            collectibleTypes[theType].spawnpoints[i].collected_by = false
        end
    end
    local countCreated = 0
    for i=1, #info.spawnpoints do
        local spawnpoint = info.spawnpoints[i]
        if spawnpoint and createOnePickup(theType, i, spawnpoint) then
            countCreated = countCreated + 1
        end
    end
    if isElement(thePlayer) then
        outputCustomText(thePlayer, "admin_spawned", countCreated, (string.gsub(theType, "_", " ")))
    end
    triggerEvent("collectibles:onSpawnedServer", root, (isElement(thePlayer) and thePlayer or "SYSTEM"), theType, countCreated)
    return true
end

--- **(Exported)**
function destroyCollectibles(theType, thePlayer)
    assert(type(theType) == "string", "Bad argument @ destroyCollectibles [expected string at argument 1, got " .. type(theType) .. "]")
    local info = collectibleTypes[theType]
    if (not info) or (info.target ~= "server") then
        if isElement(thePlayer) then
            outputCustomText(thePlayer, "admin_invalid_collectible_type", theType)
            for theType2, info2 in pairs(collectibleTypes) do
                if info2.target == "server" then
                    outputChatBox("  - " .. theType2, thePlayer, 255, 255, 255)
                end
            end
        end
        return false, "admin_invalid_collectible_type"
    end
    local total = info.total
    for i=1, total do
        local sp = info.spawnpoints[i]
        if sp then
            collectibleTypes[theType].spawnpoints[i].collected_by = false
        end
    end
    local pickupsLeft = {}
    for pickup, info2 in pairs(spawnedServerCollectibles) do
        if info2.type == theType then
            pickupsLeft[#pickupsLeft+1] = pickup
        end
    end
    if #pickupsLeft == 0 then
        if isElement(thePlayer) then
            outputCustomText(thePlayer, "admin_count_spawned", 0, (string.gsub(theType, "_", " ")))
        end
        return false, "admin_count_spawned"
    end
    for i=1, #pickupsLeft do
        local pickup = pickupsLeft[i]
        destroyElement(pickup)
        spawnedServerCollectibles[pickup] = nil
    end
    if isElement(thePlayer) then
        outputCustomText(thePlayer, "admin_destroyed", countLeft, (string.gsub(theType, "_", " ")))
    end
    triggerEvent("collectibles:onDestroyedServer", root, (isElement(thePlayer) and thePlayer or "SYSTEM"), theType, countLeft, total)
    return true
end

local function spawnClientCollectible(theType, spID, thePlayer)
    for i=1, #collectibleTypes[theType].spawnpoints do
        local spawnpoint = collectibleTypes[theType].spawnpoints[i]
        if spawnpoint and spawnpoint.spID == spID then

            triggerClientEvent(thePlayer, "collectibles:spawn", thePlayer, theType, spID, spawnpoint)
            return
        end
    end
end

local function isCollectedClient(thePlayer, account, theType, respawn_after, spID)
    local dataName = getAccountDataNames().client_counts
    local data = getAccountData(account, dataName)
    if not data then
        return false
    end
    data = fromJSON(data) or {}
    if not data[theType] then
        return false
    end
    local collectedAt = tonumber(data[theType][tostring(spID)])
    if not collectedAt then
        return false
    end
    local now = getRealTime().timestamp
    if (respawn_after) and ((now - collectedAt) > respawn_after) then
        data[theType][tostring(spID)] = nil
        setAccountData(account, dataName, toJSON(data))
        spawnClientCollectible(theType, tonumber(spID), thePlayer)
        return false
    end
    return true
end

local function sendCollectibles(player, account, thisType)
    local collectibleTypesClient = {}
    for theType, info in pairs(collectibleTypes) do
        if info.target == "client" and (not thisType or thisType == theType) then
            local spawnpoints = {}
            for i=1, #info.spawnpoints do
                local spawnpoint = info.spawnpoints[i]
                if spawnpoint then
                    local alreadyCollected = isCollectedClient(player, account, theType, info.respawn_after, spawnpoint.spID)
                    if not alreadyCollected then
                        spawnpoints[#spawnpoints+1] = {
                            spID = spawnpoint.spID,
                            x = spawnpoint.x,
                            y = spawnpoint.y,
                            z = spawnpoint.z,
                            interior = spawnpoint.interior,
                            dimension = spawnpoint.dimension,
                            model = spawnpoint.model,
                        }
                    end
                end
            end
            local toggled = (info.auto_load or false)
            collectibleTypesClient[theType] = {
                name = info.name,
                toggled = toggled,
                toggle_keybind = info.toggle_keybind,
                toggle_command = info.toggle_command,
                collect_one = info.collect_one,
                collect_all = info.collect_all,
                total = info.total,
                spawnpoints = spawnpoints,
            }
        end
    end
    triggerClientEvent(player, "collectibles:receive", player,
        collectibleTypesClient,
        CONSTANTS
    )
end

local function resendClientCollectibles()
    local playersTable = getElementsByType("player")
    for i=1, #playersTable do
        local player = playersTable[i]
        if player then
            local account = getPlayerAccount(player)
            if (account and not isGuestAccount(account)) then
                sendCollectibles(player, account)
            end
        end
    end
end

--- **(Exported)**
function removeSpawnpoint(theType, spID)
    assert(type(theType) == "string", "Bad argument @ removeSpawnpoint [expected string at argument 1, got " .. type(theType) .. "]")
    assert(type(spID) == "number", "Bad argument @ removeSpawnpoint [expected number at argument 2, got " .. type(spID) .. "]")
    local info = collectibleTypes[theType]
    if (not info) then
        return false, "admin_invalid_collectible_type"
    end
    local spawnpoint, theIndex
    for i=1, #info.spawnpoints do
        local sp = info.spawnpoints[i]
        if sp and sp.spID == spID then
            spawnpoint = sp
            theIndex = i
            break
        end
    end
    if (not spawnpoint) then
        return false, "admin_invalid_spawnpoint_index"
    end

    local config = xmlLoadFile("config.xml")
    if not config then
        return false, "Failed to load file 'config.xml'."
    end
    local children = xmlNodeGetChildren(config)
    if not children then
        xmlUnloadFile(config)
        return false, "Failed to get children of 'config.xml'."
    end

    local found = false
    for i=1, #children do
        local child = children[i]
        if child and xmlNodeGetName(child) == "spawnpoints" then
            local spawnpoints2 = xmlNodeGetChildren(child)
            if not spawnpoints2 then
                xmlUnloadFile(config)
                return false, "Failed to get children of 'spawnpoints' in 'config.xml'."
            end
            for i2=1, #spawnpoints2 do
                local spawnpoint2 = spawnpoints2[i2]
                if spawnpoint2 and xmlNodeGetName(spawnpoint2) == "spawnpoint" then
                    local theType2 = xmlNodeGetAttribute(spawnpoint2, "type")
                    if theType == theType2 then
                        local id = tonumber(xmlNodeGetAttribute(spawnpoint2, "id"))
                        if id and id == spID then
                            xmlDestroyNode(spawnpoint2)
                            found = true
                            break
                        end
                    end
                end
            end
            if found then
                break
            end
        end
    end
    if not found then
        xmlUnloadFile(config)
        return false, "Failed to find spawnpoint in 'config.xml'."
    end

    if not xmlSaveFile(config) then
        xmlUnloadFile(config)
        return false, "Failed to save file 'config.xml'."
    end
    xmlUnloadFile(config)

    table.remove(collectibleTypes[theType].spawnpoints, theIndex)

    collectibleTypes[theType].total = collectibleTypes[theType].total - 1
    for pickup, info2 in pairs(spawnedServerCollectibles) do
        if info2.type == theType and info2.spID == spID then
            destroyElement(pickup)
            spawnedServerCollectibles[pickup] = nil
        end
    end

    if info.target == "client" then
        -- reset all accounts' collected counts of this type
        local dataName = getAccountDataNames().client_counts
        local accounts = getAccounts()
        local collectedCounts = {}
        for i=1, #accounts do
            local account = accounts[i]
            if account then
                local data = getAccountData(account, dataName)
                if not data then
                    data = {}
                else
                    data = fromJSON(data) or {}
                end
                data[theType] = nil
                setAccountData(account, dataName, toJSON(data))
            end
        end

        resendClientCollectibles()
    end

    return true
end

--- **(Exported)**
function createNewSpawnpoint(theType, model, x,y,z, interior, dimension)
    assert(type(theType) == "string", "Bad argument @ createNewSpawnpoint [expected string at argument 1, got " .. type(theType) .. "]")
    assert(type(model) == "number", "Bad argument @ createNewSpawnpoint [expected number at argument 2, got " .. type(model) .. "]")
    assert(type(x) == "number", "Bad argument @ createNewSpawnpoint [expected number at argument 3, got " .. type(x) .. "]")
    assert(type(y) == "number", "Bad argument @ createNewSpawnpoint [expected number at argument 4, got " .. type(y) .. "]")
    assert(type(z) == "number", "Bad argument @ createNewSpawnpoint [expected number at argument 5, got " .. type(z) .. "]")
    assert(type(interior) == "number", "Bad argument @ createNewSpawnpoint [expected number at argument 6, got " .. type(interior) .. "]")
    assert(type(dimension) == "number", "Bad argument @ createNewSpawnpoint [expected number at argument 7, got " .. type(dimension) .. "]")
    local info = collectibleTypes[theType]
    if (not info) then
        return false, "admin_invalid_collectible_type"
    end

    local config = xmlLoadFile("config.xml")
    if not config then
        return false, "Failed to load file 'config.xml'."
    end
    local children = xmlNodeGetChildren(config)
    if not children then
        xmlUnloadFile(config)
        return false, "Failed to get children of 'config.xml'."
    end

    local lastSpID = 0
    for i=1, #info.spawnpoints do
        local spawnpoint = info.spawnpoints[i]
        if spawnpoint and spawnpoint.spID > lastSpID then
            lastSpID = spawnpoint.spID
        end
    end
    lastSpID = lastSpID + 1

    for i=1, #children do
        local child = children[i]
        if child and xmlNodeGetName(child) == "spawnpoints" then
            local newSpawnpoint = xmlCreateChild(child, "spawnpoint")
            xmlNodeSetAttribute(newSpawnpoint, "type", theType)
            xmlNodeSetAttribute(newSpawnpoint, "id", lastSpID)
            xmlNodeSetAttribute(newSpawnpoint, "model", model)
            xmlNodeSetAttribute(newSpawnpoint, "x", x)
            xmlNodeSetAttribute(newSpawnpoint, "y", y)
            xmlNodeSetAttribute(newSpawnpoint, "z", z)
            xmlNodeSetAttribute(newSpawnpoint, "interior", interior)
            xmlNodeSetAttribute(newSpawnpoint, "dimension", dimension)
            break
        end
    end
    if not xmlSaveFile(config) then
        xmlUnloadFile(config)
        return false, "Failed to save file 'config.xml'."
    end
    xmlUnloadFile(config)

    local newIndex = #collectibleTypes[theType].spawnpoints + 1
    collectibleTypes[theType].spawnpoints[newIndex] = {
        spID = lastSpID,
        model = model,
        x = x,
        y = y,
        z = z,
        interior = interior,
        dimension = dimension,
    }
    collectibleTypes[theType].total = #info.spawnpoints

    if info.target == "client" then
        resendClientCollectibles()
    else
        local pickupsSpawned = {}
        for pickup, info2 in pairs(spawnedServerCollectibles) do
            if info2.type == theType then
                pickupsSpawned[#pickupsSpawned+1] = pickup
            end
        end
        if (info.auto_load == true or #pickupsSpawned > 0) then
            createOnePickup(theType, lastSpID, collectibleTypes[theType].spawnpoints[newIndex])
        end
    end
    return lastSpID
end

local function createServerCollectibles()
    for theType, info in pairs(collectibleTypes) do
        if info.target == "server" then

            for i=1, #info.spawnpoints do
                local sp = info.spawnpoints[i]
                if sp then
                    collectibleTypes[theType].spawnpoints[i].collected_by = false
                end
            end

            if (info.auto_load == true) then
                -- Auto create on startup
                for i=1, #info.spawnpoints do
                    local spawnpoint = info.spawnpoints[i]
                    if spawnpoint then
                        createOnePickup(theType, i, spawnpoint)
                    end
                end
            end
        end
    end
end

local function countCollectedServer(accountID, theType)
    local count = 0
    for i=1, #collectibleTypes[theType].spawnpoints do
        local sp = collectibleTypes[theType].spawnpoints[i]
        if sp and sp.collected_by == accountID then
            count = count + 1
        end
    end
    return count
end

local function saveCollectedClient(account, theType, spID)
    local dataName = getAccountDataNames().client_counts
    local data = getAccountData(account, dataName)
    if not data then
        data = {}
    else
        data = fromJSON(data) or {}
    end
    if not data[theType] then
        data[theType] = {}
    end
    data[theType][tostring(spID)] = getRealTime().timestamp
    setAccountData(account, dataName, toJSON(data))
end

local function despawnCollectibles(player)
    triggerClientEvent(player, "collectibles:despawn", player)
end

local function countCollectedClient(thePlayer, account, theType, respawn_after)
    local dataName = getAccountDataNames().client_counts
    local data = getAccountData(account, dataName)
    if not data then
        return 0
    end
    data = fromJSON(data) or {}
    if not data[theType] then
        return 0
    end
    local now = getRealTime().timestamp
    local count = 0
    for spID, collectedAt in pairs(data[theType]) do
        collectedAt = tonumber(collectedAt)
        if collectedAt then
            if (respawn_after) and ((now - collectedAt) > respawn_after) then
                data[theType][tostring(spID)] = nil
                setAccountData(account, dataName, toJSON(data))

                if isElement(thePlayer) then
                    spawnClientCollectible(theType, tonumber(spID), thePlayer)
                end
            else
                count = count + 1
            end
        end
    end
    return count
end

--- **(Exported)**
function getCollectedCounts(account)
    local accountID = getAccountID(account)
    assert(type(accountID)=="number", "Bad argument @ getCollectedCounts [valid account expected, got " .. tostring(account) .. "]")
    local serverCounts = {}
    local clientCounts = {}
    for theType, info in pairs(collectibleTypes) do
        if info.target == "server" then
            local spawnedPickups = {}
            for pickup, data in pairs(spawnedServerCollectibles) do
                if data.type == theType then
                    spawnedPickups[data.spID] = pickup
                end
            end
            local count = countCollectedServer(accountID, theType)
            serverCounts[theType] = {count = count, total = info.total, spawnpoints = info.spawnpoints, spawnedPickups = spawnedPickups}
        elseif info.target == "client" then
            local count = countCollectedClient(thePlayer, account, theType, info.respawn_after)
            clientCounts[theType] = {count = count, total = info.total, spawnpoints = info.spawnpoints}
        end
    end
    return {server = serverCounts, client = clientCounts}
end

local function respawnAllClientCollectibles()
    local playersTable = getElementsByType("player")
    for i=1, #playersTable do
        local thePlayer = playersTable[i]
        if thePlayer then
            local account = getPlayerAccount(thePlayer)
            if (account) and (not isGuestAccount(account)) then
                for theType, info in pairs(collectibleTypes) do
                    if info.target == "client" then
                        local respawn_after = info.respawn_after
                        countCollectedClient(thePlayer, account, theType, respawn_after)
                    end
                end
            end
        end
    end
end

--- **(Exported)**
function resetClientCollectibles(targetAccount, theType, thePlayer)
    local targetAccountID = getAccountID(targetAccount)
    assert(type(targetAccountID)=="number", "Bad argument @ getCollectedCounts [valid account expected, got " .. tostring(targetAccount) .. "]")
    assert(type(theType) == "string", "Bad argument @ resetClientCollectibles [string expected, got " .. type(theType) .. "]")
    if theType ~= "all" and ((not collectibleTypes[theType]) or (collectibleTypes[theType].target ~= "client")) then
        if isElement(thePlayer) then
            outputCustomText(thePlayer, "admin_invalid_collectible_type", theType)
            for theType2, info2 in pairs(collectibleTypes) do
                if info2.target == "client" then
                    outputChatBox("  - " .. theType2, thePlayer, 255, 255, 255)
                end
            end
        end
        return false, "admin_invalid_collectible_type"
    end
    local dataName = getAccountDataNames().client_counts
    local data = getAccountData(targetAccount, dataName)
    if not data then
        data = {}
    else
        data = fromJSON(data) or {}
    end
    if theType == "all" then
        for theType2, info in pairs(collectibleTypes) do
            if info.target == "client" then
                data[theType2] = {}
            end
        end
    else
        data[theType] = {}
    end
    setAccountData(targetAccount, dataName, toJSON(data))
    local targetPlayer = nil
    local playersTable = getElementsByType("player")
    for i=1, #playersTable do
        local player = playersTable[i]
        if player then
            local account = getPlayerAccount(player)
            if (account) and (not isGuestAccount(account)) then
                if getAccountID(account) == targetAccountID then
                    targetPlayer = player
                    break
                end
            end
        end
    end
    if targetPlayer then
        sendCollectibles(targetPlayer, targetAccount, (theType ~= "all" and theType or nil))
        outputCustomText(targetPlayer, "admin_reset_success_player", (string.gsub(theType, "_", " ")))
    end
    if isElement(thePlayer) then
        local targetAccountName = getAccountName(targetAccount)
        outputCustomText(thePlayer, "admin_reset_success", (string.gsub(theType, "_", " ")), targetAccountName, tostring(targetAccountID))
    end
    return true
end

local function handlePickedUp(thePlayer_, collectibleInfo)
    local pickup = source
    if (thePlayer_) and (not (isElement(pickup) and getElementType(pickup) == "pickup")) then
        return
    end
    local thePlayer = client or thePlayer_
    if not (isElement(thePlayer) and getElementType(thePlayer) == "player") then
        return
    end
    if (type(collectibleTypes)~="table") then
        return
    end
    local account = getPlayerAccount(thePlayer)
    if (not account) or (isGuestAccount(account)) then
        return--hacker?
    end
    local theType = collectibleInfo.type
    if not collectibleTypes[theType] then
        return--hacker?
    end
    if not canCollectPickup(thePlayer, account, theType) then
        if client then
            triggerClientEvent(client, "collectibles:pickupDenied", client, collectibleInfo)
        end
        outputCustomText(thePlayer, "cant_pickup")
        return
    end

    -- success, pick it up:

    local accountName = getAccountName(account)
    local accountID = getAccountID(account)
    local respawn_after = collectibleTypes[theType].respawn_after
    local spID = collectibleInfo.spID
    local count
    if (not client) then
        count = countCollectedServer(accountID, theType) + 1
        for i=1, #collectibleTypes[theType].spawnpoints do
            local spawnpoint = collectibleTypes[theType].spawnpoints[i]
            if spawnpoint and (spawnpoint.spID == spID) then
                collectibleTypes[theType].spawnpoints[i].collected_by = accountID
                break
            end
        end
        destroyElement(pickup)
        spawnedServerCollectibles[pickup] = nil
    else
        count = countCollectedClient(thePlayer, account, theType, respawn_after) + 1
        saveCollectedClient(account, theType, spID)
        -- pickup will be destroyed on client
    end

    local total = collectibleTypes[theType].total

    local rewardMoney = collectibleTypes[theType].collect_one.reward_money
    if rewardMoney then
        givePlayerMoney(thePlayer, rewardMoney)
        outputCustomText(thePlayer, "reward_money", rewardMoney, (string.gsub(theType, "_", " ")))
    end

    local action
    if count == total then
        action = collectibleTypes[theType].collect_all
    else
        action = collectibleTypes[theType].collect_one
    end
    
    triggerClientEvent(thePlayer, "collectibles:actionOnPickedUp", thePlayer, theType, count, total, action)

    -- Custom Event (for Developers)
    triggerEvent("collectibles:onCollected", thePlayer, account, accountID, accountName, collectibleTypes[theType].target, theType, count, total)
end
addEventHandler("collectibles:handlePickedUp", root, handlePickedUp)

local function onPickupHit(thePlayer)
    local collectibleInfo = spawnedServerCollectibles[source]
    if not collectibleInfo then return end
    if (getElementDimension(thePlayer) ~= getElementDimension(source) or getElementInterior(thePlayer) ~= getElementInterior(source)) then return end
    triggerEvent("collectibles:handlePickedUp", source, thePlayer, collectibleInfo)
end
addEventHandler("onPickupHit", resourceRoot, onPickupHit)

addEventHandler("onPickupHit", resourceRoot, function()
    cancelEvent()
end)

addEventHandler("onPlayerLogin", root, function(_, newAccount)
    if isGuestAccount(newAccount) then
        despawnCollectibles(source)
        return
    end
    if type(clientsWaiting)=="table" then
        clientsWaiting[#clientsWaiting+1] = source
    else
        sendCollectibles(source, newAccount)
    end
end)

addEventHandler("onPlayerLogout", root, function(_, newAccount)
    if isGuestAccount(newAccount) then
        despawnCollectibles(source)
        return
    end
    if type(clientsWaiting)=="table" then
        clientsWaiting[#clientsWaiting+1] = source
    else
        sendCollectibles(source, newAccount)
    end
end)

addEventHandler("collectibles:requestCollectibles", resourceRoot, function()
    if not client then return end
    local account = getPlayerAccount(client)
    if (not account) or (isGuestAccount(account)) then return end
    sendCollectibles(client, account)
end, false)

addEventHandler("onResourceStart", resourceRoot, function()

    local success1, reason1 = parseCustomSettings()
    if not success1 then
        outputInfoMessage(reason1)
        return cancelEvent()
    end

    local success, reason = loadConfiguration()
    if not success then
        outputInfoMessage(reason)
        if fileExists("backups/config.xml") then
            outputInfoMessage("Restore the backed up configuration file 'backups/config.xml' if needed.")
        else
            outputInfoMessage("Oops, you didn't backup your configuration file so you don't have anything to restore.")
        end
        return cancelEvent()
    end

    outputInfoMessage("Successfully loaded configuration.")
    
    createServerCollectibles()

    for i=1, #clientsWaiting do
        local player = clientsWaiting[i]
        if player then
            local account = getPlayerAccount(player)
            if (account) and (not isGuestAccount(account)) then
                sendCollectibles(player, account)
            end
        end
    end

    clientsWaiting = nil -- clear memory

    setTimer(respawnAllClientCollectibles, 60000, 0)
end, false)
