--[[
    Author: https://github.com/Fernando-A-Rocha

    Collectibles - Config Editor (Server)

    /!\ Unless you know what you are doing, do not edit this file. /!\
]]

CONFIG_EDITOR_LOADED = true

-- Internal Events
addEvent("collectibles:updateConfig", true) -- source: always resourceRoot
addEvent("collectibles:createNewType", true) -- source: always resourceRoot
addEvent("collectibles:deleteType", true) -- source: always resourceRoot
addEvent("collectibles:backupConfig", true) -- source: always resourceRoot
addEvent("collectibles:restoreConfigBackup", true) -- source: always resourceRoot
addEvent("collectibles:duplicateConfigBackup", true) -- source: always resourceRoot
addEvent("collectibles:requestConfigureSpawnpoints", true) -- source: always resourceRoot
addEvent("collectibles:gotoSpawnpoint", true) -- source: always resourceRoot
addEvent("collectibles:removeSpawnpoint", true) -- source: always resourceRoot
addEvent("collectibles:createSpawnpoint", true) -- source: always resourceRoot

local antiSpam = {}
local goingToRestart = false

local function handlePermissionMismatch(thePlayer)
    outputInfoMessage("CRITICAL WARNING: "..getPlayerName(thePlayer).." ("..getAccountName(getPlayerAccount(thePlayer))
    ..") triggered an event"..(eventName and (" ("..eventName..")") or "").." for which they don't have permission.")
    oct(thePlayer, gct("You don't have permission to do this."))
end

function commandOpenEditor(thePlayer, cmd)
    if not canAdminCollectibles(thePlayer) then
        oct(thePlayer, gct("You don't have permission to do this."))
        return
    end
    if antiSpam[thePlayer] then
        oct(thePlayer, gct("Please wait a bit before doing this again."))
        return
    end
    if (goingToRestart == true) then
        oct(thePlayer, gct("The server is restarting, please wait."))
        return
    end
    antiSpam[thePlayer] = true

    local metaFileSrcs = {}
    local meta = xmlLoadFile("meta.xml", true)
    if not meta then
        antiSpam[thePlayer] = nil
        return outputChatBox("ERROR #1 (/"..cmd..").", thePlayer, 255, 0, 0)
    end
    local metaChildren = xmlNodeGetChildren(meta)
    if not metaChildren then
        antiSpam[thePlayer] = nil
        return outputChatBox("ERROR #2 (/"..cmd..").", thePlayer, 255, 0, 0)
    end
    for i=1, #metaChildren do
        local metaChild = metaChildren[i]
        if xmlNodeGetName(metaChild) == "file" then
            local src = xmlNodeGetAttribute(metaChild, "src")
            if src then
                metaFileSrcs[#metaFileSrcs + 1] = src
            end
        end
    end
    xmlUnloadFile(meta)

    local collectibleTypes = getCollectibleTypes()
    local constants = getConstants()
    local info = {
        collectibleTypes = collectibleTypes,
        backupExists = fileExists((constants.BACKUPS_DIRECTORY)..(constants.COLLECTIBLES_FILE)),
        metaFileSrcs = metaFileSrcs,
        constants = constants
    }
    
    triggerClientEvent(thePlayer, "collectibles:admin", thePlayer, info)
    
    setTimer(function()
        antiSpam[thePlayer] = nil
    end, 1000, 1)
end

local function requestUpdateConfiguration(updateNodes, updateStrings)
    if not client then return end
    if not canAdminCollectibles(client) then
        handlePermissionMismatch(client)
        return
    end

    local success, reason = updateConfiguration(updateNodes, updateStrings)
    if not success then
        return triggerClientEvent(client, "collectibles:adminResponse", client, false, reason, gct("OK"))
    end

    goingToRestart = true
    setTimer(function()
        restartResource(getThisResource())
    end, 5000, 1)

    triggerClientEvent(client, "collectibles:adminResponse", client, gct("Changes saved successfully.").."\n\n"..gct("The resource will now restart...\nPay attention to the server console."))
end
addEventHandler("collectibles:updateConfig", resourceRoot, requestUpdateConfiguration, false)

local function requestDeleteType(theType)
    if not client then return end
    if not canAdminCollectibles(client) then
        handlePermissionMismatch(client)
        return
    end

    local success, reason = deleteType(theType)
    if not success then
        return triggerClientEvent(client, "collectibles:adminResponse", client, false, reason, gct("OK"))
    end

    goingToRestart = true
    setTimer(function()
        restartResource(getThisResource())
    end, 5000, 1)

    triggerClientEvent(client, "collectibles:adminResponse", client, gct("Collectible type '%s' was permanently deleted.", theType).."\n\n"..gct("The resource will now restart...\nPay attention to the server console."))
end
addEventHandler("collectibles:deleteType", resourceRoot, requestDeleteType, false)

local function requestCreateNewType(typeInfo)
    if not client then return end
    if not canAdminCollectibles(client) then
        handlePermissionMismatch(client)
        return
    end

    local success, reason = createNewType(typeInfo)
    if not success then
        return triggerClientEvent(client, "collectibles:adminResponse", client, false, reason, gct("OK"))
    end

    goingToRestart = true
    setTimer(function()
        restartResource(getThisResource())
    end, 5000, 1)

    triggerClientEvent(client, "collectibles:adminResponse", client, gct("Collectible type '%s' created successfully.", typeInfo.name).."\n\n"..gct("The resource will now restart...\nPay attention to the server console."))
end
addEventHandler("collectibles:createNewType", resourceRoot, requestCreateNewType, false)

local function requestBackupConfiguration()
    if not client then return end
    if not canAdminCollectibles(client) then
        handlePermissionMismatch(client)
        return
    end
    local backupPath = (getConstants().BACKUPS_DIRECTORY)..(getConstants().COLLECTIBLES_FILE)
    local success, reason = backupConfiguration(backupPath)
    if not success then
        return triggerClientEvent(client, "collectibles:adminResponse", client, false, reason, gct("OK"))
    end

    triggerClientEvent(client, "collectibles:adminResponse", client, gct("Configuration backup created successfully:\n%s", backupPath), false, gct("OK"))
end
addEventHandler("collectibles:backupConfig", resourceRoot, requestBackupConfiguration, false)

local function requestRestoreConfigBackup(backupPath)
    if not client then return end
    if not canAdminCollectibles(client) then
        handlePermissionMismatch(client)
        return
    end
    if type(backupPath) ~= "string" then
        return triggerClientEvent(client, "collectibles:adminResponse", client, false, gct("Invalid arguments."), gct("OK"))
    end
    backupPath = (getConstants().BACKUPS_DIRECTORY)..backupPath
    local success, reason = restoreConfigBackup(backupPath)
    if not success then
        return triggerClientEvent(client, "collectibles:adminResponse", client, false, reason, gct("OK"))
    end

    goingToRestart = true
    setTimer(function()
        restartResource(getThisResource())
    end, 5000, 1)

    triggerClientEvent(client, "collectibles:adminResponse", client, gct("Configuration restored successfully from:\n", backupPath).."\n\n"..gct("The resource will now restart...\nPay attention to the server console."))
end
addEventHandler("collectibles:restoreConfigBackup", resourceRoot, requestRestoreConfigBackup, false)

local function requestDuplicateConfigBackup(oldPath, newPath)
    if not client then return end
    if not canAdminCollectibles(client) then
        handlePermissionMismatch(client)
        return
    end
    if type(oldPath) ~= "string" or type(newPath) ~= "string" then
        return triggerClientEvent(client, "collectibles:adminResponse", client, false, gct("Invalid arguments."), gct("OK"))
    end
    oldPath = (getConstants().BACKUPS_DIRECTORY)..oldPath
    newPath = (getConstants().BACKUPS_DIRECTORY)..newPath
    
    local dateTimeString = os.date("%Y-%m-%d_%H-%M-%S")
    newPath = string.format(newPath, dateTimeString)

    local success, reason = duplicateConfigBackup(oldPath, newPath)
    if not success then
        return triggerClientEvent(client, "collectibles:adminResponse", client, false, reason, gct("OK"))
    end

    triggerClientEvent(client, "collectibles:adminResponse", client, gct("Configuration backup copied from:\n%s\nto:\n%s", oldPath, newPath), false, gct("OK"))
end
addEventHandler("collectibles:duplicateConfigBackup", resourceRoot, requestDuplicateConfigBackup, false)

function commandConfigureSpawnpoints(thePlayer, cmd, theType)
    if not canAdminCollectibles(thePlayer) then
        oct(thePlayer, gct("You don't have permission to do this."))
        return
    end
    if not theType then
        oct(thePlayer, gct("SYNTAX: /%s %s", cmd, gct("[collectible type name]")))
        return
    end
    local collectibleTypes = getCollectibleTypes()
    local info = collectibleTypes[theType]
    if not info then
        oct(thePlayer, gct("Collectible type '%s' does not exist.", theType))
        return
    end
    triggerClientEvent(thePlayer, "collectibles:configureSpawnpoints", thePlayer, cmd, theType, info)
end

addEventHandler("collectibles:requestConfigureSpawnpoints", resourceRoot, function(theType)
    if not client then return end
    if not canAdminCollectibles(client) then
        handlePermissionMismatch(client)
        return
    end

    local command = getConstants().COMMANDS.SPAWNPOINTS
    executeCommandHandler(command, client, theType)
end, false)

local function requestGotoSpawnpoint(theType, spID)
    if not client then return end
    if not canAdminCollectibles(client) then
        handlePermissionMismatch(client)
        return
    end

    if type(spID) ~= "number" then
        return triggerClientEvent(client, "collectibles:adminResponse", client, false, "Unexpected error: spawnpoint ID is not a number", gct("OK"))
    end

    local collectibleTypes = getCollectibleTypes() or {}
    local info = collectibleTypes[theType]
    if not info then
        return triggerClientEvent(client, "collectibles:adminResponse", client, false, gct("Collectible type '%s' does not exist.", tostring(theType)), gct("OK"))
    end
    
    local spawnpoint
    for i=1, #info.spawnpoints do
        local sp = info.spawnpoints[i]
        if sp and sp.spID == spID then
            spawnpoint = sp
            break
        end
    end
    if not spawnpoint then
        return triggerClientEvent(client, "collectibles:adminResponse", client, false, gct("Collectible type '%s' doesn't have a spawnpoint with ID %s.", (string.gsub(theType, "_", " ")), spID), gct("OK"))
    end

    -- Prevent the player from picking up the collectible
    setPlayerPreventPicking(client, 5000)

    local x,y,z = spawnpoint.x, spawnpoint.y, spawnpoint.z
    local interior, dimension = spawnpoint.interior, spawnpoint.dimension

    setElementPosition(client, x,y,z)
    setElementInterior(client, interior)
    setElementDimension(client, dimension)

    triggerClientEvent(client, "collectibles:adminResponse", client, "Teleported to '"..theType.."' spawnpoint #"..spID..".", false, gct("OK"))
end
addEventHandler("collectibles:gotoSpawnpoint", resourceRoot, requestGotoSpawnpoint, false)

local function requestRemoveSpawnpoint(theType, spID)
    if not client then return end
    if not canAdminCollectibles(client) then
        handlePermissionMismatch(client)
        return
    end

    if type(spID) ~= "number" then
        return triggerClientEvent(client, "collectibles:adminResponse", client, false, "Unexpected error: spawnpoint ID is not a number", gct("OK"))
    end

    local collectibleTypes = getCollectibleTypes() or {}
    local info = collectibleTypes[theType]
    if not info then
        return triggerClientEvent(client, "collectibles:adminResponse", client, false, gct("Collectible type '%s' does not exist.", tostring(theType)), gct("OK"))
    end
    
    local spawnpoint
    for i=1, #info.spawnpoints do
        local sp = info.spawnpoints[i]
        if sp and sp.spID == spID then
            spawnpoint = sp
            break
        end
    end
    if not spawnpoint then
        return triggerClientEvent(client, "collectibles:adminResponse", client, false, gct("Collectible type '%s' doesn't have a spawnpoint with ID %s.", (string.gsub(theType, "_", " ")), spID), gct("OK"))
    end

    local success, reason = removeSpawnpoint(theType, spID)
    if not success then
        return triggerClientEvent(client, "collectibles:adminResponse", client, false, reason, gct("OK"))
    end

    triggerClientEvent(client, "collectibles:adminResponse", client, "'"..theType.."' spawnpoint #"..spID.." removed successfully.", false, gct("OK"))
end
addEventHandler("collectibles:removeSpawnpoint", resourceRoot, requestRemoveSpawnpoint, false)

local function requestCreateSpawnpoint(theType, model)
    if not client then return end
    if not canAdminCollectibles(client) then
        handlePermissionMismatch(client)
        return
    end

    local x,y,z = getElementPosition(client)
    local interior, dimension = getElementInterior(client), getElementDimension(client)

    -- Prevent the player from picking up the collectible
    setPlayerPreventPicking(client, 5000)

    local newSpID, reason = createNewSpawnpoint(theType, model, x,y,z, interior, dimension)
    if not newSpID then
        return triggerClientEvent(client, "collectibles:adminResponse", client, false, reason, gct("OK"))
    end

    triggerClientEvent(client, "collectibles:adminResponse", client, gct("You have created a new spawnpoint with ID %s (%s).", tostring(newSpID), (string.gsub(theType, "_", " "))), false, gct("OK"))
end
addEventHandler("collectibles:createSpawnpoint", resourceRoot, requestCreateSpawnpoint, false)
