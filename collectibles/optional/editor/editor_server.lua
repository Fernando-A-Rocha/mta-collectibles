--[[
    Author: https://github.com/Fernando-A-Rocha

    Collectibles - Config Editor (Server)

    /!\ Unless you know what you are doing, do not edit this file. /!\
]]

CONFIG_EDITOR_LOADED = true

-- Internal Events
addEvent("collectibles:updateConfig", true) -- source: always resourceRoot
addEvent("collectibles:createNewType", true) -- source: always resourceRoot
addEvent("collectibles:deleteType", true) -- source: always resourceRoot
addEvent("collectibles:backupConfig", true) -- source: always resourceRoot
addEvent("collectibles:restoreConfigBackup", true) -- source: always resourceRoot
addEvent("collectibles:duplicateConfigBackup", true) -- source: always resourceRoot
addEvent("collectibles:requestConfigureSpawnpoints", true) -- source: always resourceRoot
addEvent("collectibles:gotoSpawnpoint", true) -- source: always resourceRoot
addEvent("collectibles:removeSpawnpoint", true) -- source: always resourceRoot
addEvent("collectibles:createSpawnpoint", true) -- source: always resourceRoot

local antiSpam = {}
local goingToRestart = false

local function handlePermissionMismatch(thePlayer)
    outputInfoMessage("CRITICAL WARNING: "..getPlayerName(thePlayer).." ("..getAccountName(getPlayerAccount(thePlayer))
    ..") triggered an event"..(eventName and (" ("..eventName..")") or "").." for which they don't have permission.")
    outputCustomText(thePlayer, "admin_no_permission")
end

function commandOpenEditor(thePlayer, cmd)
    if not canAdminCollectibles(thePlayer) then
        outputCustomText(thePlayer, "admin_no_permission")
        return
    end
    if antiSpam[thePlayer] then
        outputCustomText(thePlayer, "ask_to_wait")
        return
    end
    if (goingToRestart == true) then
        outputCustomText(thePlayer, "ask_to_wait")
        return
    end
    antiSpam[thePlayer] = true

    local metaFileSrcs = {}
    local meta = xmlLoadFile("meta.xml", true)
    if not meta then
        antiSpam[thePlayer] = nil
        return outputChatBox("ERROR #1 (/"..cmd..").", thePlayer, 255, 0, 0)
    end
    local metaChildren = xmlNodeGetChildren(meta)
    if not metaChildren then
        antiSpam[thePlayer] = nil
        return outputChatBox("ERROR #2 (/"..cmd..").", thePlayer, 255, 0, 0)
    end
    for i=1, #metaChildren do
        local metaChild = metaChildren[i]
        if xmlNodeGetName(metaChild) == "file" then
            local src = xmlNodeGetAttribute(metaChild, "src")
            if src then
                metaFileSrcs[#metaFileSrcs + 1] = src
            end
        end
    end
    xmlUnloadFile(meta)

    local collectibleTypes = getCollectibleTypes()
    local accounts = getAccounts()
    local collectedCounts = {}
    for i=1, #accounts do
        local account = accounts[i]
        if account then
            collectedCounts[#collectedCounts + 1] = {
                accountID = getAccountID(account),
                accountName = getAccountName(account),
                counts = getCollectedCounts(account)
            }
        end
    end

    local info = {
        collectibleTypes = collectibleTypes,
        collectedCounts = collectedCounts,
        backupExists = fileExists("backups/config.xml"),
        metaFileSrcs = metaFileSrcs
    }
    
    triggerClientEvent(thePlayer, "collectibles:admin", thePlayer, info)
    
    setTimer(function()
        antiSpam[thePlayer] = nil
    end, 1000, 1)
end

local function requestUpdateConfiguration(updateNodes)
    if not client then return end
    if not canAdminCollectibles(client) then
        handlePermissionMismatch(client)
        return
    end

    local success, reason = updateConfiguration(updateNodes)
    if not success then
        return triggerClientEvent(client, "collectibles:adminResponse", client, false, reason, "OK")
    end

    goingToRestart = true
    setTimer(function()
        restartResource(getThisResource())
    end, 5000, 1)

    triggerClientEvent(client, "collectibles:adminResponse", client, gct("admin_changes_saved").."\n\n"..gct("admin_resource_restart"))
end
addEventHandler("collectibles:updateConfig", resourceRoot, requestUpdateConfiguration, false)

local function requestDeleteType(theType)
    if not client then return end
    if not canAdminCollectibles(client) then
        handlePermissionMismatch(client)
        return
    end

    local success, reason = deleteType(theType)
    if not success then
        return triggerClientEvent(client, "collectibles:adminResponse", client, false, reason, "OK")
    end

    goingToRestart = true
    setTimer(function()
        restartResource(getThisResource())
    end, 5000, 1)

    triggerClientEvent(client, "collectibles:adminResponse", client, gct("admin_collectible_type_deleted", theType).."\n\n"..gct("admin_resource_restart"))
end
addEventHandler("collectibles:deleteType", resourceRoot, requestDeleteType, false)

local function requestCreateNewType(typeInfo)
    if not client then return end
    if not canAdminCollectibles(client) then
        handlePermissionMismatch(client)
        return
    end

    local success, reason = createNewType(typeInfo)
    if not success then
        return triggerClientEvent(client, "collectibles:adminResponse", client, false, reason, "OK")
    end

    goingToRestart = true
    setTimer(function()
        restartResource(getThisResource())
    end, 5000, 1)

    triggerClientEvent(client, "collectibles:adminResponse", client, gct("admin_collectible_type_created", typeInfo.name).."\n\n"..gct("admin_resource_restart"))
end
addEventHandler("collectibles:createNewType", resourceRoot, requestCreateNewType, false)

local function requestBackupConfiguration()
    if not client then return end
    if not canAdminCollectibles(client) then
        handlePermissionMismatch(client)
        return
    end

    local success, reason = backupConfiguration()
    if not success then
        return triggerClientEvent(client, "collectibles:adminResponse", client, false, reason, "OK")
    end

    triggerClientEvent(client, "collectibles:adminResponse", client, gct("admin_config_backup_created"), false, "OK")
end
addEventHandler("collectibles:backupConfig", resourceRoot, requestBackupConfiguration, false)

local function requestRestoreConfigBackup()
    if not client then return end
    if not canAdminCollectibles(client) then
        handlePermissionMismatch(client)
        return
    end

    local success, reason = restoreConfigBackup()
    if not success then
        return triggerClientEvent(client, "collectibles:adminResponse", client, false, reason, "OK")
    end

    goingToRestart = true
    setTimer(function()
        restartResource(getThisResource())
    end, 5000, 1)

    triggerClientEvent(client, "collectibles:adminResponse", client, gct("admin_config_backup_restored").."\n\n"..gct("admin_resource_restart"))
end
addEventHandler("collectibles:restoreConfigBackup", resourceRoot, requestRestoreConfigBackup, false)

local function requestDuplicateConfigBackup(newPath)
    if not client then return end
    if not canAdminCollectibles(client) then
        handlePermissionMismatch(client)
        return
    end
    
    local dateTimeString = os.date("%Y-%m-%d_%H-%M-%S")
    newPath = string.format(newPath, dateTimeString)

    local success, reason = duplicateConfigBackup(newPath)
    if not success then
        return triggerClientEvent(client, "collectibles:adminResponse", client, false, reason, "OK")
    end

    triggerClientEvent(client, "collectibles:adminResponse", client, gct("admin_config_backup_copied", newPath), false, "OK")
end
addEventHandler("collectibles:duplicateConfigBackup", resourceRoot, requestDuplicateConfigBackup, false)

function commandConfigureSpawnpoints(thePlayer, cmd, theType)
    if not canAdminCollectibles(thePlayer) then
        outputCustomText(thePlayer, "admin_no_permission")
        return
    end
    if not theType then
        outputCustomText(thePlayer, "command_syntax", cmd, gct("syntax_collectible_type"))
        return
    end
    local collectibleTypes = getCollectibleTypes()
    local info = collectibleTypes[theType]
    if not info then
        outputCustomText(thePlayer, "admin_invalid_collectible_type", theType)
        return
    end
    triggerClientEvent(thePlayer, "collectibles:configureSpawnpoints", thePlayer, cmd, theType, info)
end

addEventHandler("collectibles:requestConfigureSpawnpoints", resourceRoot, function(theType)
    if not client then return end
    if not canAdminCollectibles(client) then
        handlePermissionMismatch(client)
        return
    end

    local command = getConstants().COMMANDS.SPAWNPOINTS
    executeCommandHandler(command, client, theType)
end, false)

local function requestGotoSpawnpoint(theType, spID)
    if not client then return end
    if not canAdminCollectibles(client) then
        handlePermissionMismatch(client)
        return
    end

    if type(spID) ~= "number" then
        return triggerClientEvent(client, "collectibles:adminResponse", client, false, "Unexpected error: spawnpoint ID is not a number", "OK")
    end

    local collectibleTypes = getCollectibleTypes() or {}
    local info = collectibleTypes[theType]
    if not info then
        return triggerClientEvent(client, "collectibles:adminResponse", client, false, gct("admin_invalid_collectible_type", tostring(theType)), "OK")
    end
    
    local spawnpoint
    for i=1, #info.spawnpoints do
        local sp = info.spawnpoints[i]
        if sp and sp.spID == spID then
            spawnpoint = sp
            break
        end
    end
    if not spawnpoint then
        return triggerClientEvent(client, "collectibles:adminResponse", client, false, gct("admin_invalid_spawnpoint_id", (string.gsub(theType, "_", " ")), spID), "OK")
    end

    -- Prevent the player from picking up the collectible
    setPlayerPreventPicking(client, 5000)

    local x,y,z = spawnpoint.x, spawnpoint.y, spawnpoint.z
    local interior, dimension = spawnpoint.interior, spawnpoint.dimension

    setElementPosition(client, x,y,z)
    setElementInterior(client, interior)
    setElementDimension(client, dimension)

    triggerClientEvent(client, "collectibles:adminResponse", client, "Teleported to '"..theType.."' spawnpoint #"..spID..".", false, "OK")
end
addEventHandler("collectibles:gotoSpawnpoint", resourceRoot, requestGotoSpawnpoint, false)

local function requestRemoveSpawnpoint(theType, spID)
    if not client then return end
    if not canAdminCollectibles(client) then
        handlePermissionMismatch(client)
        return
    end

    if type(spID) ~= "number" then
        return triggerClientEvent(client, "collectibles:adminResponse", client, false, "Unexpected error: spawnpoint ID is not a number", "OK")
    end

    local collectibleTypes = getCollectibleTypes() or {}
    local info = collectibleTypes[theType]
    if not info then
        return triggerClientEvent(client, "collectibles:adminResponse", client, false, gct("admin_invalid_collectible_type", tostring(theType)), "OK")
    end
    
    local spawnpoint
    for i=1, #info.spawnpoints do
        local sp = info.spawnpoints[i]
        if sp and sp.spID == spID then
            spawnpoint = sp
            break
        end
    end
    if not spawnpoint then
        return triggerClientEvent(client, "collectibles:adminResponse", client, false, gct("admin_invalid_spawnpoint_id", (string.gsub(theType, "_", " ")), spID), "OK")
    end

    local success, reason = removeSpawnpoint(theType, spID)
    if not success then
        return triggerClientEvent(client, "collectibles:adminResponse", client, false, reason, "OK")
    end

    triggerClientEvent(client, "collectibles:adminResponse", client, "'"..theType.."' spawnpoint #"..spID.." removed successfully.", false, "OK")
end
addEventHandler("collectibles:removeSpawnpoint", resourceRoot, requestRemoveSpawnpoint, false)

local function requestCreateSpawnpoint(theType, model)
    if not client then return end
    if not canAdminCollectibles(client) then
        handlePermissionMismatch(client)
        return
    end

    local x,y,z = getElementPosition(client)
    local interior, dimension = getElementInterior(client), getElementDimension(client)

    -- Prevent the player from picking up the collectible
    setPlayerPreventPicking(client, 5000)

    local newSpID, reason = createNewSpawnpoint(theType, model, x,y,z, interior, dimension)
    if not newSpID then
        return triggerClientEvent(client, "collectibles:adminResponse", client, false, reason, "OK")
    end

    triggerClientEvent(client, "collectibles:adminResponse", client, gct("admin_spawnpoint_created", tostring(newSpID), (string.gsub(theType, "_", " "))), false, "OK")
end
addEventHandler("collectibles:createSpawnpoint", resourceRoot, requestCreateSpawnpoint, false)
