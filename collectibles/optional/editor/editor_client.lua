--[[
    Author: https://github.com/Fernando-A-Rocha

    Collectibles - Config Editor (Client)

    /!\ Unless you know what you are doing, do not edit this file. /!\
]]

-- Internal Events
addEvent("collectibles:admin", true) -- source: always the local player
addEvent("collectibles:adminConfirm", true) -- source: always the local player
addEvent("collectibles:adminResponse", true) -- source: always the local player
addEvent("collectibles:configureSpawnpoints", true) -- source: always the local player

local KEY_NAMES = { "mouse1", "mouse2", "mouse3", "mouse4", "mouse5", "mouse_wheel_up", "mouse_wheel_down", "arrow_l", "arrow_u", --escape
"arrow_r", "arrow_d", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k",
"l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "num_0", "num_1", "num_2", "num_3", "num_4", "num_5",
"num_6", "num_7", "num_8", "num_9", "num_mul", "num_add", "num_sep", "num_sub", "num_div", "num_dec", "num_enter", "F1", "F2", "F3", "F4", "F5",
"F6", "F7", "F8", "F9", "F10", "F11", "F12", "backspace", "tab", "lalt", "ralt", "enter", "space", "pgup", "pgdn", "end", "home",
"insert", "delete", "lshift", "rshift", "lctrl", "rctrl", "[", "]", "pause", "capslock", "scroll", ";", ",", "-", ".", "/", "#", "\\", "=" }

-- For security reasons, it is also defined serverside in editor_server.lua
local BACKUPS_DIRECTORY = "backups/"

local SW, SH = guiGetScreenSize()
local popupWin = nil
local createWin = nil
local mainWin = nil
local modelWin = nil
local spWin = nil

local function rgbToHex(rgb)
	local hexadecimal = ''
	for key, value in pairs(rgb) do
		local hex = ''
		while(value > 0)do
			local ind = math.fmod(value, 16) + 1
			value = math.floor(value / 16)
			hex = string.sub('0123456789ABCDEF', ind, ind) .. hex			
		end
		if(string.len(hex) == 0)then
			hex = '00'
		elseif(string.len(hex) == 1)then
			hex = '0' .. hex
		end
		hexadecimal = hexadecimal .. hex
	end
	return hexadecimal
end

local guiSetEnabled_ = guiSetEnabled
function guiSetEnabled(element, state)
    guiSetEnabled_(element, state or false)
    if state then
        guiSetAlpha(element, 0.85)
    else
        if element == mainWin and isElement(createWin) then
            guiSetAlpha(element, 0)
        else
            guiSetAlpha(element, 0.4)
        end
    end
end

local guiCreateWindow_ = guiCreateWindow
function guiCreateWindow(x, y, w, h, title, relative, parent)
    local win = guiCreateWindow_(x, y, w, h, title, relative, parent)
    if win then
        guiSetAlpha(win, 0.85)
    end
    return win
end

function createConfirmPopup(title, titleColor, description, confirmText, cancelText, confirmEvent, confirmType, ...)
    if not (isElement(mainWin) or isElement(spWin)) then
        return
    end
    if isElement(createWin) then
        guiSetEnabled(createWin, false)
    end
    if isElement(mainWin) then
        guiSetEnabled(mainWin, false)
    end
    if isElement(spWin) then
        guiSetEnabled(spWin, false)
    end
    if isElement(modelWin) then
        guiSetEnabled(modelWin, false)
    end

    if isElement(popupWin) then
        destroyElement(popupWin)
    end
    local eventArgs = {...}

    local WW, WH = 600, SH
    popupWin = guiCreateWindow((SW-WW)/2, (SH-WH)/2, WW, WH, title, false)
    guiSetProperty(popupWin, "CaptionColour", titleColor)

    local x, y = 15, 30

    local _, countLines = description:gsub("\n","")
    countLines = countLines + 1
    local descHeight = (16*countLines)

    local descriptionLabel = guiCreateLabel(x, y, WW-10, descHeight, description, false, popupWin)
    guiSetFont(descriptionLabel, "default-bold-small")
    guiLabelSetHorizontalAlign(descriptionLabel, "center", true)
    guiLabelSetVerticalAlign(descriptionLabel, "center")
    y = y + descHeight + 15

    local confx, confwidth = 15, (2/3)*WW - (15)
    local canx, canwidth = 15 + (2/3)*WW, (1/3)*WW - 30

    if cancelText and (not confirmText) then
        canx, canwidth = confx, WW - 30
    elseif confirmText and (not cancelText) then
        confx, confwidth = confx, WW - 30
    end

    if confirmText then
        local confirm = guiCreateButton(confx, y, confwidth, 30, confirmText, false, popupWin)
        guiSetProperty(confirm, "NormalTextColour", "FF00FF00")

        addEventHandler("onClientGUIClick", confirm, function()
            guiSetEnabled(popupWin, false)
            triggerEvent(confirmEvent, localPlayer, confirmType, eventArgs)
        end, false)
    end

    if cancelText then
        local cancel = guiCreateButton(canx, y, canwidth, 30, cancelText, false, popupWin)
        addEventHandler("onClientGUIClick", cancel, function()
            destroyElement(popupWin)
            popupWin = nil
            if isElement(createWin) and not guiGetEnabled(createWin) then
                guiSetEnabled(createWin, true)
            else
                if isElement(mainWin) and not guiGetEnabled(mainWin) then
                    guiSetEnabled(mainWin, true)
                end
            end
            if isElement(modelWin) and not guiGetEnabled(modelWin) then
                guiSetEnabled(modelWin, true)
            else
                if isElement(spWin) and not guiGetEnabled(spWin) then
                    guiSetEnabled(spWin, true)
                end
            end
        end, false)
    end

    if confirmText or cancelText then
        y = y + 45
    end

    guiSetSize(popupWin, WW, y, false)
    guiSetPosition(popupWin, (SW-WW)/2, (SH-y)/2, false)
end

local function showValidationError(msg)
    createConfirmPopup(gct("Validation Error"), "FFFF0000", msg, false, gct("OK"))
end

local function openCreateCollectible(metaFileSrcs)
    local WW, WH = 750, 550
    createWin = guiCreateWindow((SW-WW)/2, (SH-WH)/2, WW, WH, gct("Create New Collectible"), false)
    guiSetEnabled(mainWin, false)

    local x, y = 15, 0

    local scrollPane = guiCreateScrollPane(x, y, WW-30, WH-60, false, createWin)

    local PW2 = guiGetSize(scrollPane, false)

    guiCreateLabel(0, y, PW2, 20, " ", false, scrollPane)
    y = y + 40

    local typeNameLabel = guiCreateLabel(0, y, PW2, 20, gct("Name:"), false, scrollPane)
    y = y + 20 + 5

    local typeNameEdit = guiCreateEdit(0, y, PW2*(1/3), 24, "", false, scrollPane)
    y = y + 24 + 10

    local autoLoadCheckbox = guiCreateCheckBox(0, y, PW2*(1/3), 24, gct("Spawn Automatically"), true, false, scrollPane)
    y = y + 24 + 10

    local targetLabel = guiCreateLabel(0, y, (PW2*(1/3))/2, 20, gct("Target:"), false, scrollPane)
    y = y + 20 + 5

    local targetDropdown = guiCreateComboBox(0, y, (PW2*(1/3))/2, 24*3, "", false, scrollPane)
    guiComboBoxAddItem(targetDropdown, "client")
    guiComboBoxAddItem(targetDropdown, "server")
    guiComboBoxSetSelected(targetDropdown, 0) -- default: client
    y = y + 24 + 6

    local respawnAfterCheckbox = guiCreateCheckBox(0, y, PW2*(1/3), 20, gct("(Optional)  Respawn After:"), false, false, scrollPane)
    y = y + 20 + 5

    local respawnAfterEdit = guiCreateEdit(0, y, (PW2*(1/3)) * (1/3), 24, "", false, scrollPane)
    local respawnAfterUnitDropdown = guiCreateComboBox((PW2*(1/3)) * (1/3) + 5, y, (PW2*(2/3)) * (1/3), 24*6, "", false, scrollPane)
    local RESPAWN_UNITS = {
        {name="seconds", niceName=gct("Seconds")},
        {name="minutes", niceName=gct("Minutes")},
        {name="hours", niceName=gct("Hours")},
        {name="days", niceName=gct("Days")},
        {name="weeks", niceName=gct("Weeks")},
    }
    for i=1, #RESPAWN_UNITS do
        guiComboBoxAddItem(respawnAfterUnitDropdown, RESPAWN_UNITS[i].niceName)
    end
    guiComboBoxSetSelected(respawnAfterUnitDropdown, 1) -- default: minutes
    guiSetEnabled(respawnAfterEdit, false)
    guiSetEnabled(respawnAfterUnitDropdown, false)
    y = y + 24 + 6

    local toggleCommandCheckbox = guiCreateCheckBox(0, y, PW2*(1/3), 20, gct("(Optional)  Toggle Command:"), false, false, scrollPane)
    y = y + 20 + 5

    local toggleCommandEdit = guiCreateEdit(0, y, PW2*(1/3), 24, "", false, scrollPane)
    guiSetEnabled(toggleCommandEdit, false)
    y = y + 24 + 6

    local toggleKeyBindCheckbox = guiCreateCheckBox(0, y, PW2*(1/3), 20, gct("(Optional)  Toggle Key Bind:"), false, false, scrollPane)
    y = y + 20 + 5

    local toggleKeyBindEdit = guiCreateEdit(0, y, PW2*(1/3), 24, "", false, scrollPane)
    guiSetEnabled(toggleKeyBindEdit, false)
    y = y + 24 + 35

    -- Client/Server select logic
    addEventHandler("onClientGUIClick", scrollPane, function()
        if source == respawnAfterCheckbox then
            guiSetEnabled(respawnAfterEdit, guiCheckBoxGetSelected(source))
            guiSetEnabled(respawnAfterUnitDropdown, guiCheckBoxGetSelected(source))
        elseif source == toggleCommandCheckbox then
            guiSetEnabled(toggleCommandEdit, guiCheckBoxGetSelected(source))
        elseif source == toggleKeyBindCheckbox then
            guiSetEnabled(toggleKeyBindEdit, guiCheckBoxGetSelected(source))
        end
    end)
    addEventHandler("onClientGUIComboBoxAccepted", targetDropdown, function()
        local item = guiComboBoxGetSelected(source)
        if item == 0 then -- selected client
            guiSetEnabled(respawnAfterCheckbox, true)
            guiSetEnabled(respawnAfterEdit, guiCheckBoxGetSelected(respawnAfterCheckbox))
            guiSetEnabled(respawnAfterUnitDropdown, guiCheckBoxGetSelected(respawnAfterCheckbox))
            guiSetEnabled(toggleCommandCheckbox, true)
            guiSetEnabled(toggleCommandEdit, guiCheckBoxGetSelected(toggleCommandCheckbox))
            guiSetEnabled(toggleKeyBindCheckbox, true)
            guiSetEnabled(toggleKeyBindEdit, guiCheckBoxGetSelected(toggleKeyBindCheckbox))
        else -- selected server
            guiSetEnabled(respawnAfterCheckbox, false)
            guiCheckBoxSetSelected(respawnAfterCheckbox, false)
            guiSetEnabled(respawnAfterEdit, false)
            guiSetEnabled(respawnAfterUnitDropdown, false)
            guiSetEnabled(toggleCommandCheckbox, false)
            guiCheckBoxSetSelected(toggleCommandCheckbox, false)
            guiSetEnabled(toggleCommandEdit, false)
            guiSetEnabled(toggleKeyBindCheckbox, false)
            guiCheckBoxSetSelected(toggleKeyBindCheckbox, false)
            guiSetEnabled(toggleKeyBindEdit, false)
            
            guiSetText(respawnAfterEdit, "")
            guiSetText(toggleCommandEdit, "")
            guiSetText(toggleKeyBindEdit, "")
        end
    end, false)

    -- Fixes unselect bug when you click on the dropdown but not on any option
    addEventHandler("onClientGUIClick", scrollPane, function()
        setTimer(function()
            local item1 = guiComboBoxGetSelected(targetDropdown)
            if item1 == -1 then
                guiComboBoxSetSelected(targetDropdown, 0) -- default: client
                triggerEvent("onClientGUIComboBoxAccepted", targetDropdown)
            end
            local item2 = guiComboBoxGetSelected(respawnAfterUnitDropdown)
            if item2 == -1 then
                guiComboBoxSetSelected(respawnAfterUnitDropdown, 1) -- default: minutes
                triggerEvent("onClientGUIComboBoxAccepted", respawnAfterUnitDropdown)
            end
        end, 50, 1)
    end)

    -- Bottom margin
    guiCreateLabel(0, y, 50, 60, " ", false, scrollPane)

    -- Right side
    x = x + (PW2/2) + 10
    y = 40

    local actionsTitle = guiCreateLabel(x, y, PW2*(1/3), 20, gct("Actions"), false, scrollPane)
    guiSetFont(actionsTitle, "default-bold-small")
    y = y + 20 + 5

    local actionsText = gct("Here you can define what happens when a collectible is picked up and when it's the last one found.")
    local actionsLabel = guiCreateLabel(x, y, PW2*(1/3) + 55, 40, actionsText, false, scrollPane)
    guiLabelSetHorizontalAlign(actionsLabel, "left", true)
    y = y + 40 + 6

    local onCollectLabel = guiCreateLabel(x, y, PW2*(1/3), 20, gct("On Collect:"), false, scrollPane)
    guiLabelSetColor(onCollectLabel, 255, 0, 255)
    y = y + 20 + 5

    local playSoundCheckbox = guiCreateCheckBox(x+10, y, PW2*(1/3), 20, gct("(Optional)  Play Sound"), false, false, scrollPane)
    y = y + 20 + 5

    local soundLabel = guiCreateLabel(x+10, y, PW2*(1/3), 20, gct("Sound File Path:"), false, scrollPane)
    local soundVolumeLabel = guiCreateLabel(x+10 + (PW2*(1/3)) + 5, y, 60, 24, gct("Volume:"), false, scrollPane)

    local soundEdit = guiCreateEdit(x+10, y + 20 + 5, PW2*(1/3), 24, "", false, scrollPane)
    local soundVolumeEdit = guiCreateEdit(x+10 + (PW2*(1/3)) + 5, y + 20 + 5, 50, 24, "", false, scrollPane)
    y = y + 20 + 24 + 25

    guiSetEnabled(soundEdit, false)
    guiSetEnabled(soundVolumeEdit, false)

    local onCollectAllLabel = guiCreateLabel(x, y, PW2*(1/3), 20, gct("On Collect Last:"), false, scrollPane)
    guiLabelSetColor(onCollectAllLabel, 255, 0, 255)
    y = y + 20 + 5

    local playSoundAllCheckbox = guiCreateCheckBox(x+10, y, PW2*(1/3), 20, gct("(Optional)  Play Sound"), false, false, scrollPane)
    y = y + 20 + 5

    local soundAllLabel = guiCreateLabel(x+10, y, PW2*(1/3), 20, gct("Sound File Path:"), false, scrollPane)
    local soundAllVolumeLabel = guiCreateLabel(x+10 + (PW2*(1/3)) + 5, y, 60, 24, gct("Volume:"), false, scrollPane)

    local soundAllEdit = guiCreateEdit(x+10, y + 20 + 5, PW2*(1/3), 24, "", false, scrollPane)
    local soundAllVolumeEdit = guiCreateEdit(x+10 + (PW2*(1/3)) + 5, y + 20 + 5, 50, 24, "", false, scrollPane)
    -- y = y + 20 + 24 + 25

    guiSetEnabled(soundAllEdit, false)
    guiSetEnabled(soundAllVolumeEdit, false)

    -- Click sound checkboxes logic
    addEventHandler("onClientGUIClick", scrollPane, function()
        if source == playSoundCheckbox then
            if guiCheckBoxGetSelected(playSoundCheckbox) then
                guiSetEnabled(soundEdit, true)
                guiSetEnabled(soundVolumeEdit, true)
                guiSetEnabled(soundVolumeLabel, true)
            else
                guiSetEnabled(soundEdit, false)
                guiSetEnabled(soundVolumeEdit, false)
                guiSetEnabled(soundVolumeLabel, false)
            end
        elseif source == playSoundAllCheckbox then
            if guiCheckBoxGetSelected(playSoundAllCheckbox) then
                guiSetEnabled(soundAllEdit, true)
                guiSetEnabled(soundAllVolumeEdit, true)
                guiSetEnabled(soundAllVolumeLabel, true)
            else
                guiSetEnabled(soundAllEdit, false)
                guiSetEnabled(soundAllVolumeEdit, false)
                guiSetEnabled(soundAllVolumeLabel, false)
            end
        end
    end)

    -- Bottom buttons

    local cancel = guiCreateButton(WW - 10 - 100, WH - 10 - 30, 100, 30, gct("Cancel"), false, createWin)
    local confirm = guiCreateButton(WW - 10 - 100 - 10 - 100, WH - 10 - 30, 100, 30, gct("Create"), false, createWin)
    guiSetProperty(confirm, "NormalTextColour", "FF00FF00")

    addEventHandler("onClientGUIClick", createWin, function()
        if source == cancel then
            destroyElement(createWin)
            createWin = nil
            if isElement(mainWin) and not guiGetEnabled(mainWin) then
                guiSetEnabled(mainWin, true)
            end
        elseif source == confirm then
            local typeName = guiGetText(typeNameEdit)
            if typeName == "" then
                return showValidationError(gct("Name cannot be empty"))
            end
            typeName = string.gsub(typeName, " ", "_")
            
            local typeAutoLoad = guiCheckBoxGetSelected(autoLoadCheckbox)
            local target = guiComboBoxGetItemText(targetDropdown, guiComboBoxGetSelected(targetDropdown))

            local respawnAfter, respawnAfterUnit, toggleCommand, toggleKeyBind
           
            -- optional client parameters
            if guiCheckBoxGetSelected(respawnAfterCheckbox) then
                respawnAfter = guiGetText(respawnAfterEdit)
                respawnAfter = tonumber(respawnAfter)
                if (not respawnAfter) or (respawnAfter < 0) then
                    return showValidationError(gct("Respawn After must be a positive number"))
                end
                respawnAfter = tostring(respawnAfter)
                local respawnUnitItem = guiComboBoxGetSelected(respawnAfterUnitDropdown)
                for i=1, #RESPAWN_UNITS do
                    if i == (respawnUnitItem+1) then
                        respawnAfterUnit = RESPAWN_UNITS[i].name
                        break
                    end
                end
            end
            if guiCheckBoxGetSelected(toggleCommandCheckbox) then
                toggleCommand = guiGetText(toggleCommandEdit)
                if toggleCommand == "" then
                    return showValidationError(gct("Toggle command cannot be empty"))
                end
                if toggleCommand:find(" ") then
                    return showValidationError(gct("Toggle command cannot contain spaces"))
                end
            end
            if guiCheckBoxGetSelected(toggleKeyBindCheckbox) then
                toggleKeyBind = guiGetText(toggleKeyBindEdit)
                if toggleKeyBind == "" then
                    return showValidationError(gct("Toggle keybind cannot be empty"))
                end
                if toggleKeyBind:find(" ") then
                    return showValidationError(gct("Toggle keybind cannot contain spaces"))
                end
                toggleKeyBind = string.lower(toggleKeyBind)
                local found = false
                for i=1, #KEY_NAMES do
                    if toggleKeyBind == string.lower(KEY_NAMES[i]) then
                        found = true
                        break
                    end
                end
                if not found then
                    return showValidationError(gct("Toggle keybind must be a valid key name"))
                end
            end

            local oneSound, oneVolume
            if guiCheckBoxGetSelected(playSoundCheckbox) then
                oneVolume = tonumber(guiGetText(soundVolumeEdit))
                if (not oneVolume) or (oneVolume < 0) then
                    return showValidationError(gct("Sound volume on 'collect_one' must be a positive number"))
                end
                oneVolume = tostring(oneVolume)
                oneSound = guiGetText(soundEdit)
                if oneSound == "" then
                    return showValidationError(gct("Sound on 'collect_one' cannot be empty"))
                end
                local found = false
                for i=1, #metaFileSrcs do
                    local src = metaFileSrcs[i]
                    if src and src == oneSound then
                        found = true
                        break
                    end
                end
                if not found then
                    return showValidationError(gct("Sound file path on 'collect_one' does not exist"))
                end
            end

            local allSound, allVolume
            if guiCheckBoxGetSelected(playSoundAllCheckbox) then
                allVolume = tonumber(guiGetText(soundAllVolumeEdit))
                if (not allVolume) or (allVolume < 0) then
                    return showValidationError(gct("Sound volume on 'collect_last' must be a positive number"))
                end
                allVolume = tostring(allVolume)
                allSound = guiGetText(soundAllEdit)
                if allSound == "" then
                    return showValidationError(gct("Sound on 'collect_last' cannot be empty"))
                end
                local found = false
                for i=1, #metaFileSrcs do
                    local src = metaFileSrcs[i]
                    if src and src == allSound then
                        found = true
                        break
                    end
                end
                if not found then
                    return showValidationError(gct("Sound file path on 'collect_last' does not exist"))
                end
            end

            local theType = {
                name = typeName,
                auto_load = tostring(typeAutoLoad),
                target = target,
                respawn_after = respawnAfter,
                respawn_after_unit = respawnAfterUnit,
                toggle_command = toggleCommand,
                toggle_key_bind = toggleKeyBind,
                actions = {
                    collect_one = {
                        sound = oneSound,
                        sound_volume = oneVolume
                    },
                    collect_last = {
                        sound = allSound,
                        sound_volume = allVolume
                    }
                }
            }

            local desc = gct("Are you sure you want to create a new collectible type:\n%s", typeName)
            if typeAutoLoad then
                desc = desc..gct("\nIt will be automatically loaded on %s start.", target)
            end
            createConfirmPopup(gct("Confirm Creation"), "FFFFFF00", desc, gct("Confirm"), gct("Cancel"),
                "collectibles:adminConfirm", "create", theType)
        end
    end)
end

addEventHandler("collectibles:admin", localPlayer, function(serverInfo)
    if isElement(mainWin) then
        destroyElement(mainWin)
    end
    if isElement(createWin) then
        destroyElement(createWin)
    end
    guiSetInputMode("no_binds_when_editing")
    showCursor(true)

    local WW, WH = 800, 600
    mainWin = guiCreateWindow((SW-WW)/2, (SH-WH)/2, WW, WH, gct("Collectibles - Editor"), false)

    local x, y = 15, 20
    
    local tabPanel = guiCreateTabPanel(x, y, WW-(x*2), WH - 80, false, mainWin)

    -- Types

    local settings = {}

    local tabTypes = guiCreateTab(gct("Types"), tabPanel)
    local TW, TH = guiGetSize(tabTypes, false)

    local ct = 0
    for theType, info in pairs(serverInfo.collectibleTypes) do
        ct = ct + 1
    end

    if ct == 0 then
        local noTypesLabel = guiCreateLabel(0, 0, TW, TH, gct("No collectible types have been defined."), false, tabTypes)
        guiLabelSetColor(noTypesLabel, 255, 0, 0)
    else
        x, y = 5, 5

        local targetExplanation = gct("There are two possible collectible 'targets':\n• [client]: The collectibles are created on each client only. Toggle command/bind and respawn time can be defined.\nDon't forget to define a toggle command/keybind if 'Spawn Automatically' is disabled.\n• [server]: The collectibles are created on the server and all players will compete for them.")
        
        local _, countLines = targetExplanation:gsub("\n","")
        countLines = countLines + 1

        local targetExplanationLabel = guiCreateLabel(x+10, y, TW-20, (16*countLines), targetExplanation, false, tabTypes)
        guiLabelSetColor(targetExplanationLabel, 245, 227, 66)
        guiLabelSetVerticalAlign(targetExplanationLabel, "center")
        y = y + (16*countLines) + 5

        local createTypeButton = guiCreateButton(x, y, 160, 24, gct("Create Collectible Type"), false, tabTypes)
        addEventHandler("onClientGUIClick", createTypeButton, function()
            openCreateCollectible(serverInfo.metaFileSrcs)
        end, false)
        guiSetProperty(createTypeButton, "NormalTextColour", "FF00FF00")
        y = y + 24 + 5

        local tabPanelTypes = guiCreateTabPanel(x, y, TW-(x*2), TH-y-5, false, tabTypes)
        local PW = guiGetSize(tabPanelTypes, false)

        settings.types = {}
        settings.actions = {}

        for theType, info in pairs(serverInfo.collectibleTypes) do

            x = 10
            y = 0
            local tab = guiCreateTab(theType, tabPanelTypes)
            local TW2, TH2 = guiGetSize(tab, false)

            local tabScroll = guiCreateScrollPane(x, y, TW2-(x*2), TH2-15, false, tab)
            
            local PW2 = guiGetSize(tabScroll, false)
            PW2 = PW2 - 10

            guiCreateLabel(0, y, PW2, 10, " ", false, tabScroll)
            y = y + 15
            
            local typeNameLabel = guiCreateLabel(0, y, PW2, 20, gct("Name:"), false, tabScroll)
            y = y + 20 + 5

            local typeNameEdit = guiCreateEdit(0, y, PW2*(1/3), 24, theType, false, tabScroll)
            y = y + 24 + 10

            local autoLoadCheckbox = guiCreateCheckBox(0, y, PW2*(1/3), 24, gct("Spawn Automatically"), info.auto_load, false, tabScroll)
            y = y + 24 + 10

            local targetLabel = guiCreateLabel(0, y, (PW2*(1/3))/2, 20, gct("Target:"), false, tabScroll)
            local spawnPointsLabel = guiCreateLabel((PW*(1/3))/2 + 5, y, (PW*(1/3))/2, 20, gct("Spawn Points:"), false, tabScroll)
            y = y + 20 + 5

            local targetDropdown = guiCreateComboBox(0, y, (PW2*(1/3))/2, 24*3, "", false, tabScroll)
            guiComboBoxAddItem(targetDropdown, "client")
            guiComboBoxAddItem(targetDropdown, "server")
            guiComboBoxSetSelected(targetDropdown, info.target == "client" and 0 or 1)

            local spawnPointsButton = guiCreateButton((PW*(1/3))/2 + 5, y, (PW*(1/3))/2, 24, gct("Configure"), false, tabScroll)
            guiSetProperty(spawnPointsButton, "NormalTextColour", "FFFFFFFF")
            addEventHandler("onClientGUIClick", spawnPointsButton, function()

                showCursor(false)
                guiSetInputMode("allow_binds")
                destroyElement(mainWin)
                mainWin = nil
                
                triggerServerEvent("collectibles:requestConfigureSpawnpoints", resourceRoot, theType)
            end, false)
            y = y + 24 + 6

            local respawnAfterCheckbox = guiCreateCheckBox(0, y, PW2*(1/3), 20, gct("(Optional)  Respawn After:"), false, false, tabScroll)
            y = y + 20 + 5

            local respawnAfterEdit = guiCreateEdit(0, y, (PW2*(1/3)) * (1/3), 24, "", false, tabScroll)
            local respawnAfterUnitDropdown = guiCreateComboBox((PW2*(1/3)) * (1/3) + 5, y, (PW2*(2/3)) * (1/3), 24*6, "", false, tabScroll)
            local RESPAWN_UNITS = {
                {name="seconds", niceName=gct("Seconds")},
                {name="minutes", niceName=gct("Minutes")},
                {name="hours", niceName=gct("Hours")},
                {name="days", niceName=gct("Days")},
                {name="weeks", niceName=gct("Weeks")},
            }
            for i=1, #RESPAWN_UNITS do
                guiComboBoxAddItem(respawnAfterUnitDropdown, RESPAWN_UNITS[i].niceName)
            end
            if info.respawn_after_nonconverted and info.respawn_after_unit then
                guiCheckBoxSetSelected(respawnAfterCheckbox, true)
                guiSetText(respawnAfterEdit, info.respawn_after_nonconverted)
                guiComboBoxSetSelected(respawnAfterUnitDropdown,
                    info.respawn_after_unit == "seconds" and 0
                    or info.respawn_after_unit == "minutes" and 1
                    or info.respawn_after_unit == "hours" and 2
                    or info.respawn_after_unit == "days" and 3
                    or info.respawn_after_unit == "weeks" and 4
                )
            else
                guiSetEnabled(respawnAfterEdit, false)
                guiSetEnabled(respawnAfterUnitDropdown, false)
            end
            y = y + 24 + 6

            local toggleCommandCheckbox = guiCreateCheckBox(0, y, PW2*(1/3), 20, gct("(Optional)  Toggle Command:"), false, false, tabScroll)
            y = y + 20 + 5

            local toggleCommandEdit = guiCreateEdit(0, y, PW2*(1/3), 24, "", false, tabScroll)
            if info.toggle_command then
                guiCheckBoxSetSelected(toggleCommandCheckbox, true)
                guiSetText(toggleCommandEdit, info.toggle_command)
            else
                guiSetEnabled(toggleCommandEdit, false)
            end
            y = y + 24 + 6

            local toggleKeyBindCheckbox = guiCreateCheckBox(0, y, PW2*(1/3), 20, gct("(Optional)  Toggle Key Bind:"), false, false, tabScroll)
            y = y + 20 + 5

            local toggleKeyBindEdit = guiCreateEdit(0, y, PW2*(1/3), 24, "", false, tabScroll)
            if info.toggle_keybind then
                guiCheckBoxSetSelected(toggleKeyBindCheckbox, true)
                guiSetText(toggleKeyBindEdit, info.toggle_keybind)
            else
                guiSetEnabled(toggleKeyBindEdit, false)
            end
            y = y + 24 + 35

            -- Client/Server select logic
            if info.target == "server" then
                guiSetEnabled(respawnAfterCheckbox, false)
                guiSetEnabled(respawnAfterEdit, false)
                guiSetEnabled(respawnAfterUnitDropdown, false)
                guiSetEnabled(toggleCommandCheckbox, false)
                guiSetEnabled(toggleCommandEdit, false)
                guiSetEnabled(toggleKeyBindCheckbox, false)
                guiSetEnabled(toggleKeyBindEdit, false)
            end
            addEventHandler("onClientGUIClick", tabScroll, function()
                if source == respawnAfterCheckbox then
                    guiSetEnabled(respawnAfterEdit, guiCheckBoxGetSelected(source))
                    guiSetEnabled(respawnAfterUnitDropdown, guiCheckBoxGetSelected(source))
                elseif source == toggleCommandCheckbox then
                    guiSetEnabled(toggleCommandEdit, guiCheckBoxGetSelected(source))
                elseif source == toggleKeyBindCheckbox then
                    guiSetEnabled(toggleKeyBindEdit, guiCheckBoxGetSelected(source))
                end
            end)
            addEventHandler("onClientGUIComboBoxAccepted", targetDropdown, function()
                local item = guiComboBoxGetSelected(source)
                if item == 0 then -- selected client
                    guiSetEnabled(respawnAfterCheckbox, true)
                    guiSetEnabled(respawnAfterEdit, guiCheckBoxGetSelected(respawnAfterCheckbox))
                    guiSetEnabled(respawnAfterUnitDropdown, guiCheckBoxGetSelected(respawnAfterCheckbox))
                    guiSetEnabled(toggleCommandCheckbox, true)
                    guiSetEnabled(toggleCommandEdit, guiCheckBoxGetSelected(toggleCommandCheckbox))
                    guiSetEnabled(toggleKeyBindCheckbox, true)
                    guiSetEnabled(toggleKeyBindEdit, guiCheckBoxGetSelected(toggleKeyBindCheckbox))
                else -- selected server
                    guiSetEnabled(respawnAfterCheckbox, false)
                    guiCheckBoxSetSelected(respawnAfterCheckbox, false)
                    guiSetEnabled(respawnAfterEdit, false)
                    guiSetEnabled(respawnAfterUnitDropdown, false)
                    guiSetEnabled(toggleCommandCheckbox, false)
                    guiCheckBoxSetSelected(toggleCommandCheckbox, false)
                    guiSetEnabled(toggleCommandEdit, false)
                    guiSetEnabled(toggleKeyBindCheckbox, false)
                    guiCheckBoxSetSelected(toggleKeyBindCheckbox, false)
                    guiSetEnabled(toggleKeyBindEdit, false)
                    
                    guiSetText(respawnAfterEdit, "")
                    guiSetText(toggleCommandEdit, "")
                    guiSetText(toggleKeyBindEdit, "")
                end
            end, false)

            -- Fixes unselect bug when you click on the dropdown but not on any option
            addEventHandler("onClientGUIClick", tabScroll, function()
                setTimer(function()
                    local item1 = guiComboBoxGetSelected(targetDropdown)
                    if item1 == -1 then
                        guiComboBoxSetSelected(targetDropdown, info.target == "client" and 0 or 1)
                        triggerEvent("onClientGUIComboBoxAccepted", targetDropdown)
                    end
                    if info.respawn_after_unit then
                        local item2 = guiComboBoxGetSelected(respawnAfterUnitDropdown)
                        if item2 == -1 then
                            guiComboBoxSetSelected(respawnAfterUnitDropdown,
                                info.respawn_after_unit == "seconds" and 0
                                or info.respawn_after_unit == "minutes" and 1
                                or info.respawn_after_unit == "hours" and 2
                                or info.respawn_after_unit == "days" and 3
                                or info.respawn_after_unit == "weeks" and 4
                            )
                            triggerEvent("onClientGUIComboBoxAccepted", respawnAfterUnitDropdown)
                        end
                    end
                end, 50, 1)
            end)

            local statsInfoLabel = guiCreateLabel(0, y, PW2, 20, gct("INFO: View all server and player stats related to this collectible:"), false, tabScroll)
            guiLabelSetHorizontalAlign(statsInfoLabel, "left", true)
            guiLabelSetColor(statsInfoLabel, 110, 240, 255)
            y = y + 20 + 5

            local statsButton = guiCreateButton(0, y, 160, 24, gct("View Stats"), false, tabScroll)
            addEventHandler("onClientGUIClick", statsButton, function()
                outputChatBox("Coming soon!", 200, 200, 200)
            end, false)
            guiSetProperty(statsButton, "NormalTextColour", "ff6ef0ff")
            y = y + 24 + 25

            local deleteInfoLabel = guiCreateLabel(0, y, PW2, 20, gct("DANGER: Deletes this type's spawnpoints and collected counts of all player accounts:"), false, tabScroll)
            guiLabelSetHorizontalAlign(deleteInfoLabel, "left", true)
            guiLabelSetColor(deleteInfoLabel, 255, 0, 0)
            y = y + 20 + 5

            local deleteTypeButton = guiCreateButton(0, y, 160, 24, gct("Delete This Type"), false, tabScroll)
            addEventHandler("onClientGUIClick", deleteTypeButton, function()
                local desc = gct("Are you sure you want to delete collectible type:\n%s", theType)
                desc = desc ..gct("\nThis will delete all corresponding spawnpoints and\ncollected counts of all player accounts.")
                createConfirmPopup(gct("Delete Collectible Type"), "FFFF0000", desc, gct("Confirm"), gct("Cancel"),
                    "collectibles:adminConfirm", "remove", theType)
            end, false)
            guiSetProperty(deleteTypeButton, "NormalTextColour", "FFFF0000")
            y = y + 24 + 5

            -- Bottom margin
            guiCreateLabel(0, y, 50, 60, " ", false, tabScroll)

            settings.types[theType] = {

                -- edits:
                typeName = typeNameEdit,
                typeRespawnAfterOn = toggleCommandCheckbox,
                typeRespawnAfter = respawnAfterEdit,
                typeToggleCommandOn = toggleCommandCheckbox,
                typeToggleCommand = toggleCommandEdit,
                typeToggleKeyBindOn = toggleKeyBindCheckbox,
                typeToggleKeyBind = toggleKeyBindEdit,

                -- dropdowns:
                typeTarget = targetDropdown,
                typeRespawnAfterUnit = respawnAfterUnitDropdown,

                -- checkboxes:
                typeAutoLoad = autoLoadCheckbox,
            }


            -- Right side
            x = x + (PW2/2)
            y = 15

            local actionsTitle = guiCreateLabel(x, y, PW2*(1/3), 20, gct("Actions"), false, tabScroll)
            guiSetFont(actionsTitle, "default-bold-small")
            y = y + 20 + 5

            local actionsText = gct("Here you can define what happens when a collectible is picked up and when it's the last one found.")
            local actionsLabel = guiCreateLabel(x, y, PW2*(1/3) + 55, 40, actionsText, false, tabScroll)
            guiLabelSetHorizontalAlign(actionsLabel, "left", true)
            y = y + 40 + 6

            local onCollectLabel = guiCreateLabel(x, y, PW2*(1/3), 20, gct("On Collect:"), false, tabScroll)
            guiLabelSetColor(onCollectLabel, 255, 0, 255)
            y = y + 20 + 5

            local playSoundCheckbox = guiCreateCheckBox(x+10, y, PW2*(1/3), 20, gct("(Optional)  Play Sound"), false, false, tabScroll)
            y = y + 20 + 5

            local soundLabel = guiCreateLabel(x+10, y, PW2*(1/3), 20, gct("Sound File Path:"), false, tabScroll)
            local soundVolumeLabel = guiCreateLabel(x+10 + (PW2*(1/3)) + 5, y, 60, 24, gct("Volume:"), false, tabScroll)

            local soundEdit = guiCreateEdit(x+10, y + 20 + 5, PW2*(1/3), 24, "", false, tabScroll)
            local soundVolumeEdit = guiCreateEdit(x+10 + (PW2*(1/3)) + 5, y + 20 + 5, 50, 24, "", false, tabScroll)
            if info.collect_one.sound and info.collect_one.sound_volume then
                guiCheckBoxSetSelected(playSoundCheckbox, true)
                guiSetText(soundEdit, tostring(info.collect_one.sound))
                guiSetText(soundVolumeEdit, tostring(info.collect_one.sound_volume))
            else
                guiSetEnabled(soundEdit, false)
                guiSetEnabled(soundVolumeEdit, false)
            end
            y = y + 20 + 24 + 25

            local onCollectAllLabel = guiCreateLabel(x, y, PW2*(1/3), 20, gct("On Collect Last:"), false, tabScroll)
            guiLabelSetColor(onCollectAllLabel, 255, 0, 255)
            y = y + 20 + 5

            local playSoundAllCheckbox = guiCreateCheckBox(x+10, y, PW2*(1/3), 20, gct("(Optional)  Play Sound"), false, false, tabScroll)
            y = y + 20 + 5

            local soundAllLabel = guiCreateLabel(x+10, y, PW2*(1/3), 20, gct("Sound File Path:"), false, tabScroll)
            local soundAllVolumeLabel = guiCreateLabel(x+10 + (PW2*(1/3)) + 5, y, 60, 24, gct("Volume:"), false, tabScroll)

            local soundAllEdit = guiCreateEdit(x+10, y + 20 + 5, PW2*(1/3), 24, "", false, tabScroll)
            local soundAllVolumeEdit = guiCreateEdit(x+10 + (PW2*(1/3)) + 5, y + 20 + 5, 50, 24, "", false, tabScroll)
            -- y = y + 20 + 24 + 25

            if info.collect_last.sound and info.collect_last.sound_volume then
                guiCheckBoxSetSelected(playSoundAllCheckbox, true)
                guiSetText(soundAllEdit, tostring(info.collect_last.sound))
                guiSetText(soundAllVolumeEdit, tostring(info.collect_last.sound_volume))
            else
                guiSetEnabled(soundAllEdit, false)
                guiSetEnabled(soundAllVolumeEdit, false)
            end

            -- Click sound checkboxes logic
            addEventHandler("onClientGUIClick", tabScroll, function()
                if source == playSoundCheckbox then
                    if guiCheckBoxGetSelected(playSoundCheckbox) then
                        guiSetEnabled(soundEdit, true)
                        guiSetEnabled(soundVolumeEdit, true)
                        guiSetEnabled(soundVolumeLabel, true)
                    else
                        guiSetEnabled(soundEdit, false)
                        guiSetEnabled(soundVolumeEdit, false)
                        guiSetEnabled(soundVolumeLabel, false)
                    end
                elseif source == playSoundAllCheckbox then
                    if guiCheckBoxGetSelected(playSoundAllCheckbox) then
                        guiSetEnabled(soundAllEdit, true)
                        guiSetEnabled(soundAllVolumeEdit, true)
                        guiSetEnabled(soundAllVolumeLabel, true)
                    else
                        guiSetEnabled(soundAllEdit, false)
                        guiSetEnabled(soundAllVolumeEdit, false)
                        guiSetEnabled(soundAllVolumeLabel, false)
                    end
                end
            end)

            settings.actions[theType] = {
                collect_one = {
                    playSound = playSoundCheckbox,
                    sound = soundEdit,
                    soundVolume = soundVolumeEdit,
                },
                collect_last = {
                    playSound = playSoundAllCheckbox,
                    sound = soundAllEdit,
                    soundVolume = soundAllVolumeEdit,
                }
            }
        end
    end

    -- Misc (other configs)

    local tabMisc = guiCreateTab(gct("Misc"), tabPanel)

    x = 10
    y = 15

    local backupLabel = guiCreateLabel(x, y, TW-(x*2), 20, gct("Configuration Backups"), false, tabMisc)
    y = y + 20 + 5

    x = x + 10

    local backupExists = gct("File '%s' (default) currently exists in the server's file system.", "backups/config.xml")
    local bR, bG, bB = 0, 255, 0
    if not serverInfo.backupExists then
        backupExists = gct("File '%s' (default) could not be found in the server's file system.", "backups/config.xml")
        bR, bG, bB = 255, 0, 0
    end
    local backupExistsLabel = guiCreateLabel(x, y, TW-(x*2), 20, backupExists, false, tabMisc)
    guiLabelSetColor(backupExistsLabel, bR, bG, bB)

    local backupCreateButton = guiCreateButton(x, y + 20 + 5, (TW*(1/3))-(x*2), 24, gct("Create Backup"), false, tabMisc)
    guiSetProperty(backupCreateButton, "NormalTextColour", "FF00FF00")

    local backupRestoreButton = guiCreateButton(x + (TW*(1/3)) - x, y + 20 + 5, (TW*(1/3)) - x, 24, gct("Restore Backup"), false, tabMisc)
    guiSetProperty(backupRestoreButton, "NormalTextColour", "FFFFFF00")

    local backupDuplicateButton = guiCreateButton(x + (TW*(1/3)) - x + (TW*(1/3)), y + 20 + 5, (TW*(1/3)) - x, 24, gct("Duplicate Backup"), false, tabMisc)
    guiSetProperty(backupDuplicateButton, "NormalTextColour", "FF00FFFF")

    -- Bottom buttons

    local save = guiCreateButton(15, WH - 45, (2/3)*WW - (15), 30, gct("Save Changes"), false, mainWin)
    guiSetProperty(save, "NormalTextColour", "FF00FF00")

    local close = guiCreateButton(15 + (2/3)*WW, WH - 45, (1/3)*WW - 30, 30, gct("Close"), false, mainWin)

    -- Button interactions

    addEventHandler("onClientGUIClick", mainWin, function()
        
        if source == save then

            local updateNodes = {}

            for settingType, list in pairs(settings) do
                for name, info in pairs(list) do
                    if not updateNodes[settingType] then
                        updateNodes[settingType] = {}
                    end
                    updateNodes[settingType][name] = {}
                    if settingType == "types" then
                        updateNodes[settingType][name].attributeNames = {name=name}
                        updateNodes[settingType][name].attributes = {
                            auto_load = tostring(guiCheckBoxGetSelected(info.typeAutoLoad)),
                            target = guiComboBoxGetItemText(info.typeTarget, guiComboBoxGetSelected(info.typeTarget)),
                        }
                        local nameText = guiGetText(info.typeName)
                        if nameText == "" then
                            return showValidationError(gct("Name for '%s' cannot be empty", name))
                        end
                        nameText = string.gsub(nameText, " ", "_")
                        if nameText ~= name then
                            updateNodes[settingType][name].attributes.name = nameText
                        end
                        -- optional client parameters
                        if guiCheckBoxGetSelected(info.typeRespawnAfterOn) then
                            local respawnAfter = guiGetText(info.typeRespawnAfter)
                            respawnAfter = tonumber(respawnAfter)
                            if (not respawnAfter) or (respawnAfter < 0) then
                                return showValidationError(gct("Respawn After for '%s' must be a positive number", name))
                            end
                            updateNodes[settingType][name].attributes.respawn_after = tostring(respawnAfter)
                            local respawnUnitItem = guiComboBoxGetSelected(info.typeRespawnAfterUnit)
                            for i=1, #RESPAWN_UNITS do
                                if i == (respawnUnitItem+1) then
                                    updateNodes[settingType][name].attributes.respawn_after_unit = RESPAWN_UNITS[i].name
                                    break
                                end
                            end
                        else
                            updateNodes[settingType][name].attributes.respawn_after = false
                            updateNodes[settingType][name].attributes.respawn_after_unit = false
                        end
                        if guiCheckBoxGetSelected(info.typeToggleCommandOn) then
                            local typeToggleCommand = guiGetText(info.typeToggleCommand)
                            if typeToggleCommand == "" then
                                return showValidationError(gct("Toggle command for '%s' cannot be empty", name))
                            end
                            if typeToggleCommand:find(" ") then
                                return showValidationError(gct("Toggle command for '%s' cannot contain spaces", name))
                            end
                            updateNodes[settingType][name].attributes.toggle_command = typeToggleCommand
                        else
                            updateNodes[settingType][name].attributes.toggle_command = false
                        end
                        if guiCheckBoxGetSelected(info.typeToggleKeyBindOn) then
                            local typeToggleKeyBind = guiGetText(info.typeToggleKeyBind)
                            if typeToggleKeyBind == "" then
                                return showValidationError(gct("Toggle keybind for '%s' cannot be empty", name))
                            end
                            if typeToggleKeyBind:find(" ") then
                                return showValidationError(gct("Toggle keybind for '%s' cannot contain spaces", name))
                            end
                            typeToggleKeyBind = string.lower(typeToggleKeyBind)
                            local found = false
                            for i=1, #KEY_NAMES do
                                if typeToggleKeyBind == string.lower(KEY_NAMES[i]) then
                                    found = true
                                    break
                                end
                            end
                            if not found then
                                return showValidationError(gct("Toggle keybind for '%s' must be a valid key name", name))
                            end
                            updateNodes[settingType][name].attributes.toggle_keybind = typeToggleKeyBind
                        else
                            updateNodes[settingType][name].attributes.toggle_keybind = false
                        end
                    elseif settingType == "actions" then
                        local collect_one = info.collect_one
                        local collect_last = info.collect_last
                        for on, info2 in pairs({collect_one = info.collect_one, collect_last = info.collect_last}) do
                            local i = #updateNodes[settingType]+1
                            updateNodes[settingType][i] = { attributeNames = {type=name, on=on} }
                            if guiCheckBoxGetSelected(info2.playSound) then
                                local volume = tonumber(guiGetText(info2.soundVolume))
                                if (not volume) or (volume < 0) then
                                    return showValidationError(gct("Sound volume for '%s - %s' must be a positive number", name, on))
                                end
                                local sound = guiGetText(info2.sound)
                                if sound == "" then
                                    return showValidationError(gct("Sound for '%s - %s' cannot be empty", name, on))
                                end
                                local found = false
                                for w=1, #serverInfo.metaFileSrcs do
                                    local src = serverInfo.metaFileSrcs[w]
                                    if src and src == sound then
                                        found = true
                                        break
                                    end
                                end
                                if not found then
                                    return showValidationError(gct("Sound file path for '%s - %s' does not exist", name, on))
                                end
                                updateNodes[settingType][i].attributes = {
                                    sound = sound,
                                    sound_volume = tostring(volume),
                                }
                            else
                                updateNodes[settingType][i].attributes = {
                                    sound = false,
                                    sound_volume = false,
                                }
                            end
                        end
                    end
                end
            end
    
            local saveDesc = gct("Are you sure you want to save these changes?\nThis will restart the resource if successful.")
            createConfirmPopup(gct("Save Changes"), "FFFFFF00", saveDesc, gct("Confirm"), gct("Cancel"),
                "collectibles:adminConfirm", "save", updateNodes)

        elseif source == close then
           
            showCursor(false)
            guiSetInputMode("allow_binds")
            destroyElement(mainWin)
            mainWin = nil

        elseif source == backupCreateButton then

            local desc = gct("Are you sure you want to create a backup of the current configuration?\n%s", BACKUPS_DIRECTORY.."config.xml")
            if serverInfo.backupExists then
                desc = desc ..gct("\n\nWARNING: This will overwrite the existing backup.")
            end
            createConfirmPopup(gct("Create Backup"), "FFFFFF00", desc, gct("Confirm"), gct("Cancel"),
                "collectibles:adminConfirm", "backupCreate", "config.xml")

        elseif source == backupRestoreButton then

            guiSetEnabled(mainWin, false)
            local win = guiCreateWindow((SW-500)/2, (SH-130)/2, 500, 130, gct("Restore Backup"), false)
            local labelCurrPath = guiCreateLabel(10, 25, 500-20, 20, gct("Backed up configuration file (%s...):", BACKUPS_DIRECTORY), false, win)
            local PLACEHOLDER_PATH = "config.xml"
            local currName = guiCreateEdit(10, 50, 500-20, 30, PLACEHOLDER_PATH, false, win)
            addEventHandler("onClientGUIClick", currName, function()
                if guiGetText(source) == PLACEHOLDER_PATH then
                    guiSetText(source, "")
                end
            end, false)
            local cancel = guiCreateButton(10, 90, 140, 30, gct("Cancel"), false, win)
            local ok = guiCreateButton(160, 90, 140, 30, gct("Confirm"), false, win)
            guiSetProperty(ok, "NormalTextColour", "FF00FF00")
            addEventHandler("onClientGUIClick", ok, function()
                local oldName = guiGetText(currName)
                if oldName == "" then
                    return showValidationError(gct("Backup name cannot be empty"))
                end
                if oldName:find(" ") then
                    return showValidationError(gct("Backup name cannot contain spaces"))
                end
                destroyElement(win)
                
                local desc = gct("Are you sure you want to restore the configuration from:\n%s%s", BACKUPS_DIRECTORY, oldName)
                createConfirmPopup(gct("Restore Backup"), "FFFFFF00", desc, gct("Confirm"), gct("Cancel"),
                    "collectibles:adminConfirm", "backupRestore", oldName)

            end, false)
            addEventHandler("onClientGUIClick", cancel, function()
                destroyElement(win)
                guiSetEnabled(mainWin, true)
            end, false)

        elseif source == backupDuplicateButton then

            guiSetEnabled(mainWin, false)
            local win = guiCreateWindow((SW-500)/2, (SH-160)/2, 500, 160, gct("Duplicate Backup"), false)
            local labeldesc = guiCreateLabel(10, 25, 500, 40, gct("You can use %s in the new path for the current server date-time string."), false, win)
            guiLabelSetHorizontalAlign(labeldesc, "center")
            local labelCurrPath = guiCreateLabel(10, 55, 500/2-10, 20, gct("Copy file (%s...):", BACKUPS_DIRECTORY), false, win)
            local labelNewPath = guiCreateLabel(10+500/2, 55, 500/2-20, 20, gct("To new file (%s...):", BACKUPS_DIRECTORY), false, win)
            local PLACEHOLDER_PATH = "config_%s.xml"
            local currName = guiCreateEdit(10, 80, 500/2-10, 30, "config.xml", false, win)
            local name = guiCreateEdit(10+500/2, 80, 500/2-20, 30, PLACEHOLDER_PATH, false, win)
            addEventHandler("onClientGUIClick", name, function()
                if guiGetText(source) == PLACEHOLDER_PATH then
                    guiSetText(source, "")
                end
            end, false)
            local cancel = guiCreateButton(10, 120, 140, 30, gct("Cancel"), false, win)
            local ok = guiCreateButton(160, 120, 140, 30, gct("Confirm"), false, win)
            guiSetProperty(ok, "NormalTextColour", "FF00FF00")
            addEventHandler("onClientGUIClick", ok, function()
                local newName = guiGetText(name)
                if newName == "" then
                    return showValidationError(gct("Backup name cannot be empty"))
                end
                if newName:find(" ") then
                    return showValidationError(gct("Backup name cannot contain spaces"))
                end
                local oldName = guiGetText(currName)
                if oldName == "" then
                    return showValidationError(gct("Backup name cannot be empty"))
                end
                if oldName:find(" ") then
                    return showValidationError(gct("Backup name cannot contain spaces"))
                end
                destroyElement(win)
                local desc = gct("Are you sure you want to duplicate the backup from:\n%s\nto:\n%s", BACKUPS_DIRECTORY..oldName, BACKUPS_DIRECTORY..newName)
                createConfirmPopup(gct("Duplicate Backup"), "FFFFFF00", desc, gct("Confirm"), gct("Cancel"),
                    "collectibles:adminConfirm", "backupDuplicate", oldName, newName)
            end, false)
            addEventHandler("onClientGUIClick", cancel, function()
                destroyElement(win)
                guiSetEnabled(mainWin, true)
            end, false)
        end
    end)
end, false)

local function openCreateNewSpawnpoint(theType, lastModelID)
    guiSetEnabled(spWin, false)
    local WW, WH = 250, 500
    modelWin = guiCreateWindow((SW-WW)/2, (SH-WH)/2, WW, WH, gct("Create New %s Spawnpoint", theType), false)

    local MODELS = {
        { "  CUSTOM", -1 },
        { "Money (wad of cash)", 1212 },
        { "Health (heart)", 1240 },
        { "Armour", 1242 },
        { "Info icon", 1239 },
        { "House (blue)", 1272 },
        { "House (green)", 1273 },
        { "Adrenaline", 1241 },
        { "Bribe", 1247 },
        { "GTA III sign", 1248 },
        { "Bomb from GTA III", 1252 },
        { "Photo op", 1253 },
        { "Skull", 1254 },
        { "Money icon", 1274 },
        { "Blue t-shirt", 1275 },
        { "Save disk", 1277 },
        { "2 Skulls", 1313 },
        { "2 Players icon", 1314 },
        { "Tiki statue", 1276 },
        { "Parachute (with leg straps)", 1310 },
        { "Down arrow", 1318 },
        { "Drug bundle", 1279 },
    }
    local MODEL_EDIT_PLACEHOLDER = gct("Valid Object ID")

    y = 30
    local modelLabel = guiCreateLabel(15, 30, (WW-30), 20, gct("Model:"), false, modelWin)
    guiLabelSetColor(modelLabel, 255, 255, 255)
    guiSetFont(modelLabel, "default-bold-small")
    y = y + 20 + 5

    local modelCombobox = guiCreateComboBox(15, y, (WW-30), WH-26-10-26-5-y, gct("Select a model"), false, modelWin)
    for i=1, #MODELS do
        local model = MODELS[i]
        if i == 1 then
            guiComboBoxAddItem(modelCombobox, model[1])
        else
            guiComboBoxAddItem(modelCombobox, model[2]..": "..model[1])
        end
    end
    y = y + 26 + 5

    local chosenModelID = nil
    local customModelEdit = guiCreateEdit(15, y, (WW-30), 26, "", false, modelWin)
    guiSetEnabled(customModelEdit, false)
    addEventHandler("onClientGUIChanged", customModelEdit, function()
        local modelID = tonumber(guiGetText(source))
        if not modelID then
            chosenModelID = nil
            guiLabelSetColor(modelLabel, 255, 0, 0)
        elseif isDefaultObjectID(modelID) then
            chosenModelID = modelID
            guiLabelSetColor(modelLabel, 0, 255, 0)
        end
    end, false)
    guiSetText(customModelEdit, MODEL_EDIT_PLACEHOLDER)
    
    -- Bottom buttons

    local confirmButton = guiCreateButton(15, WH-26-10-26-5, (WW-30), 26, gct("Confirm"), false, modelWin)
    guiSetProperty(confirmButton, "NormalTextColour", "FF00FF00")

    local cancelButton = guiCreateButton(15, WH-26-10, (WW-30), 26, gct("Cancel"), false, modelWin)
    
    addEventHandler("onClientGUIClick", modelWin, function()

        if source == cancelButton then
            destroyElement(modelWin)
            modelWin = nil
            if isElement(spWin) and not guiGetEnabled(spWin) then
                guiSetEnabled(spWin, true)
            end
        
        elseif source == confirmButton then
            
            if not chosenModelID then
                local infoDesc = gct("You must select or type a valid object model ID.")
                createConfirmPopup(gct("Information"), "FFFFFF00", infoDesc, false, gct("OK"))
                return
            end

            local desc = gct("Are you sure you want to create a new\n'%s' (model: %s)\nspawnpoint at your current location?", theType, chosenModelID)
            createConfirmPopup(gct("Create Spawnpoint"), "FF00FF00", desc, gct("Confirm"), gct("Cancel"),
                "collectibles:adminConfirm", "createSpawnpoint", theType, chosenModelID)
        
        elseif source == customModelEdit then
            if guiGetText(source) == MODEL_EDIT_PLACEHOLDER then
                guiSetText(source, "")
            end
        end
    end)

    addEventHandler("onClientGUIComboBoxAccepted", modelCombobox, function()
        local item = guiComboBoxGetSelected(modelCombobox)
        if item == -1 then
            guiComboBoxSetSelected(source, -1)--in case it gets unselected by accident
            chosenModelID = nil
            guiLabelSetColor(modelLabel, 255, 255, 255)
            return
        end

        if item == 0 then
            -- custom
            guiLabelSetColor(modelLabel, 255, 255, 255)
            chosenModelID = nil
            guiSetText(customModelEdit, MODEL_EDIT_PLACEHOLDER)
            guiSetEnabled(customModelEdit, true)
        else
            guiSetEnabled(customModelEdit, false)
            guiSetText(customModelEdit, MODEL_EDIT_PLACEHOLDER)
            chosenModelID = MODELS[item+1][2]
            guiLabelSetColor(modelLabel, 0, 255, 0)
        end
    end, false)

    for i=1, #MODELS do
        if lastModelID and MODELS[i][2] == lastModelID then
            guiComboBoxSetSelected(modelCombobox, i-1)
            chosenModelID = lastModelID
            guiLabelSetColor(modelLabel, 0, 255, 0)
            break
        end
    end
end

addEventHandler("collectibles:configureSpawnpoints", localPlayer, function(commandName, theType, info)
    if isElement(spWin) then
        destroyElement(spWin)
    end
    if isElement(modelWin) then
        destroyElement(modelWin)
    end
    if isElement(mainWin) then
        guiSetInputMode("allow_binds")
        destroyElement(mainWin)
        mainWin = nil
    end
    showCursor(true)

    local WW, WH = 600, 400
    spWin = guiCreateWindow((SW-WW)/2, (SH-WH)/2, WW, WH, theType.. " - /"..commandName, false)

    local spList = guiCreateGridList(0.05, 0.05, 0.9, 0.7, true, spWin)
    guiGridListAddColumn(spList, gct("ID"), 0.12)
    guiGridListAddColumn(spList, gct("Model"), 0.12)
    guiGridListAddColumn(spList, gct("X Coord"), 0.12)
    guiGridListAddColumn(spList, gct("Y Coord"), 0.12)
    guiGridListAddColumn(spList, gct("Z Coord"), 0.12)
    guiGridListAddColumn(spList, gct("Interior"), 0.12)
    guiGridListAddColumn(spList, gct("Dimension"), 0.12)

    for i=1, #info.spawnpoints do
        local spawnpoint = info.spawnpoints[i]
        if spawnpoint then
            local row = guiGridListAddRow(spList)
            guiGridListSetItemText(spList, row, 1, tostring(spawnpoint.spID), false, false)
            guiGridListSetItemText(spList, row, 2, tostring(spawnpoint.model), false, false)
            guiGridListSetItemText(spList, row, 3, tostring(spawnpoint.x), false, false)
            guiGridListSetItemText(spList, row, 4, tostring(spawnpoint.y), false, false)
            guiGridListSetItemText(spList, row, 5, tostring(spawnpoint.z), false, false)
            guiGridListSetItemText(spList, row, 6, tostring(spawnpoint.interior), false, false)
            guiGridListSetItemText(spList, row, 7, tostring(spawnpoint.dimension), false, false)
        end
    end

    local spAdd = guiCreateButton(0.05, 0.8, 0.2, 0.15, gct("Add"), true, spWin)
    guiSetProperty(spAdd, "NormalTextColour", "FF00FF00")
    
    local spRemove = guiCreateButton(0.3, 0.8, 0.2, 0.15, gct("Remove"), true, spWin)
    guiSetProperty(spRemove, "NormalTextColour", "FFFF0000")
    guiSetEnabled(spRemove, false)

    local spGoto = guiCreateButton(0.55, 0.8, 0.2, 0.15, gct("Teleport"), true, spWin)
    guiSetProperty(spGoto, "NormalTextColour", "FFFFFFFF")
    guiSetEnabled(spGoto, false)

    local spClose = guiCreateButton(0.8, 0.8, 0.15, 0.15, gct("Close"), true, spWin)
    
    addEventHandler("onClientGUIClick", spWin, function()
        if source == spClose then
            showCursor(false)
            destroyElement(spWin)
            spWin = nil
        else
            local row = guiGridListGetSelectedItem(spList)
            if row == -1 then
                guiSetEnabled(spRemove, false)
                guiSetEnabled(spGoto, false)
            else
                guiSetEnabled(spRemove, true)
                guiSetEnabled(spGoto, true)
            end

            if source == spAdd then
                local lastModelID = tonumber(guiGridListGetItemText(spList, guiGridListGetRowCount(spList)-1, 2))
                openCreateNewSpawnpoint(theType, lastModelID)

            elseif source == spGoto then
                local spID = tonumber(guiGridListGetItemText(spList, row, 1))
                triggerServerEvent("collectibles:gotoSpawnpoint", resourceRoot, theType, spID)

            elseif source == spRemove then

                local spID = guiGridListGetItemText(spList, row, 1)
                local desc = gct("Are you sure you want to remove spawnpoint #%s?", tostring(spID))
                createConfirmPopup(gct("Remove Spawnpoint"), "FF00FF00", desc, gct("Confirm"), gct("Cancel"),
                    "collectibles:adminConfirm", "removeSpawnpoint", theType, tonumber(spID))
            end
        end
    end)
end, false)

addEventHandler("collectibles:adminConfirm", localPlayer, function(confirmType, eventArgs)
    if isElement(popupWin) then
        destroyElement(popupWin)
        popupWin = nil
    end

    if confirmType == "closeMainWindow" then
        
        if isElement(mainWin) then
            showCursor(false)
            guiSetInputMode("allow_binds")
            destroyElement(mainWin)
            mainWin = nil
        end
        if isElement(createWin) then
            showCursor(false)
            guiSetInputMode("allow_binds")
            destroyElement(createWin)
            createWin = nil
        end
        if isElement(spWin) then
            showCursor(false)
            destroyElement(spWin)
            spWin = nil
        end
        if isElement(modelWin) then
            showCursor(false)
            destroyElement(modelWin)
            modelWin = nil
        end
    else
        if isElement(createWin) and guiGetEnabled(createWin) then
            guiSetEnabled(createWin, false)
        else
            if isElement(mainWin) and guiGetEnabled(mainWin) then
                guiSetEnabled(mainWin, false)
            end
        end
        if isElement(modelWin) and guiGetEnabled(modelWin) then
            guiSetEnabled(modelWin, false)
        else
            if isElement(spWin) and guiGetEnabled(spWin) then
                guiSetEnabled(spWin, false)
            end
        end

        if confirmType == "save" then
            triggerServerEvent("collectibles:updateConfig", resourceRoot, eventArgs[1])
        
        elseif confirmType == "remove" then
            triggerServerEvent("collectibles:deleteType", resourceRoot, eventArgs[1])
        
        elseif confirmType == "create" then
            triggerServerEvent("collectibles:createNewType", resourceRoot, eventArgs[1])
        
        elseif confirmType == "backupCreate" then
            triggerServerEvent("collectibles:backupConfig", resourceRoot, eventArgs[1])

        elseif confirmType == "backupRestore" then
            triggerServerEvent("collectibles:restoreConfigBackup", resourceRoot, eventArgs[1])

        elseif confirmType == "backupDuplicate" then
            triggerServerEvent("collectibles:duplicateConfigBackup", resourceRoot, eventArgs[1], eventArgs[2])
        
        elseif confirmType == "createSpawnpoint" then
            triggerServerEvent("collectibles:createSpawnpoint", resourceRoot, eventArgs[1], eventArgs[2])

        elseif confirmType == "removeSpawnpoint" then
            triggerServerEvent("collectibles:removeSpawnpoint", resourceRoot, eventArgs[1], eventArgs[2])
        end
    end
end, false)

addEventHandler("collectibles:adminResponse", localPlayer, function(success, failureReason, okText)
    if (success) then
        if okText then
            createConfirmPopup(gct("Success"), "FF00FF00", success, okText, false,
                "collectibles:adminConfirm", "closeMainWindow")
        else
            createConfirmPopup(gct("Success"), "FF00FF00", success, false, false)
        end
    else
        createConfirmPopup(gct("Error"), "FFFF0000", tostring(failureReason), false, okText or false)
    end
end, false)
